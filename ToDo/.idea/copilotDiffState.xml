<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/todo/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/todo/MainActivity.kt" />
              <option name="originalContent" value="package com.example.todo&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.Comment&#10;import androidx.compose.material.icons.automirrored.filled.List&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Attachment&#10;import androidx.compose.material.icons.filled.CalendarToday&#10;import androidx.compose.material.icons.filled.Clear&#10;import androidx.compose.material.icons.filled.DarkMode&#10;import androidx.compose.material.icons.filled.Event&#10;import androidx.compose.material.icons.filled.FilterList&#10;import androidx.compose.material.icons.filled.History&#10;import androidx.compose.material.icons.filled.LightMode&#10;import androidx.compose.material.icons.filled.MoreVert&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material.icons.filled.Timeline&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.DatePicker&#10;import androidx.compose.material3.DatePickerDialog&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.core.content.ContextCompat&#10;import com.example.todo.ui.theme.ToDoTheme&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;// Data model now includes a stable id to map reminders to tasks and recurring task support&#10;&#10;data class TodoItem(&#10;    val title: String,&#10;    val notes: String = &quot;&quot;,&#10;    val isDone: Boolean = false,&#10;    val dueDate: String = &quot;&quot;,&#10;    val category: String = &quot;Personal&quot;,&#10;    val priority: String = &quot;Medium&quot;,&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val isRecurring: Boolean = false,&#10;    val recurrenceType: RecurrenceType = RecurrenceType.NONE,&#10;    val customInterval: Int = 1, // for custom intervals (e.g., every 3 days)&#10;    val lastCompleted: String = &quot;&quot;, // track when last completed for recurring tasks&#10;    val originalId: String = &quot;&quot;, // to link recurring instances to original task&#10;    val createdDate: String = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date()),&#10;    val completedDate: String = &quot;&quot;,&#10;    val completionPercentage: Int = 0, // 0-100 for progress tracking&#10;    val comments: List&lt;TaskComment&gt; = emptyList(),&#10;    val attachments: List&lt;TaskAttachment&gt; = emptyList(),&#10;    val streak: Int = 0 // for recurring tasks&#10;)&#10;&#10;data class TaskComment(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val text: String,&#10;    val timestamp: String = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;)&#10;&#10;data class TaskAttachment(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val name: String,&#10;    val type: String, // &quot;image&quot;, &quot;document&quot;, &quot;link&quot;&#10;    val uri: String,&#10;    val timestamp: String = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;)&#10;&#10;data class ActivityLogEntry(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val taskId: String,&#10;    val taskTitle: String,&#10;    val action: String, // &quot;created&quot;, &quot;completed&quot;, &quot;updated&quot;, &quot;deleted&quot;, &quot;comment_added&quot;, etc.&#10;    val details: String = &quot;&quot;,&#10;    val timestamp: String = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;)&#10;&#10;enum class RecurrenceType {&#10;    NONE,&#10;    DAILY,&#10;    WEEKLY,&#10;    MONTHLY,&#10;    CUSTOM_DAYS&#10;}&#10;&#10;enum class ViewMode {&#10;    LIST,&#10;    CALENDAR&#10;}&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            ToDoTheme {&#10;                MainScreen()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnsureNotificationPermission() {&#10;    val context = LocalContext.current&#10;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;        val permission = Manifest.permission.POST_NOTIFICATIONS&#10;        val launcher = rememberLauncherForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { /* no-op */ }&#10;        LaunchedEffect(Unit) {&#10;            val granted = ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED&#10;            if (!granted) launcher.launch(permission)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen() {&#10;    EnsureNotificationPermission()&#10;    val context = LocalContext.current&#10;&#10;    var todos by remember { mutableStateOf(listOf&lt;TodoItem&gt;()) }&#10;    var activityLog by remember { mutableStateOf(listOf&lt;ActivityLogEntry&gt;()) }&#10;    var showAddDialog by remember { mutableStateOf(false) }&#10;    var showEditDialog by remember { mutableStateOf(false) }&#10;    var showFilterDialog by remember { mutableStateOf(false) }&#10;    var showActivityDialog by remember { mutableStateOf(false) }&#10;    var showTaskDetailsDialog by remember { mutableStateOf(false) }&#10;    var editingTodo by remember { mutableStateOf&lt;TodoItem?&gt;(null) }&#10;    var selectedTodoForDetails by remember { mutableStateOf&lt;TodoItem?&gt;(null) }&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedCategory by remember { mutableStateOf(&quot;All&quot;) }&#10;    var selectedPriority by remember { mutableStateOf(&quot;All&quot;) }&#10;    var showCompleted by remember { mutableStateOf(true) }&#10;    var viewMode by remember { mutableStateOf(ViewMode.LIST) }&#10;    var isDarkTheme by remember { mutableStateOf(isSystemInDarkTheme()) }&#10;&#10;    // Filter logic&#10;    val filteredTodos = remember(todos, searchQuery, selectedCategory, selectedPriority, showCompleted) {&#10;        todos.filter { todo -&gt;&#10;            val matchesSearch = searchQuery.isBlank() ||&#10;                todo.title.contains(searchQuery, ignoreCase = true) ||&#10;                todo.notes.contains(searchQuery, ignoreCase = true)&#10;            val matchesCategory = selectedCategory == &quot;All&quot; || todo.category == selectedCategory&#10;            val matchesPriority = selectedPriority == &quot;All&quot; || todo.priority == selectedPriority&#10;            val matchesCompletion = showCompleted || !todo.isDone&#10;&#10;            matchesSearch &amp;&amp; matchesCategory &amp;&amp; matchesPriority &amp;&amp; matchesCompletion&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = Modifier.fillMaxSize(),&#10;        floatingActionButton = {&#10;            FloatingActionButton(&#10;                onClick = { showAddDialog = true },&#10;                containerColor = Color(0xFF4A90E2)&#10;            ) {&#10;                Icon(Icons.Default.Add, contentDescription = &quot;Add&quot;, tint = Color.White)&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            // Top App Bar with theme toggle and view mode&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;My Tasks&quot;,&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Row {&#10;                    // Theme Toggle&#10;                    IconButton(onClick = { isDarkTheme = !isDarkTheme }) {&#10;                        Icon(&#10;                            if (isDarkTheme) Icons.Filled.LightMode else Icons.Filled.DarkMode,&#10;                            contentDescription = &quot;Toggle theme&quot;&#10;                        )&#10;                    }&#10;                    // Activity Log Button&#10;                    IconButton(onClick = { showActivityDialog = true }) {&#10;                        Icon(Icons.Filled.History, contentDescription = &quot;Activity Log&quot;)&#10;                    }&#10;                    // View Mode Toggle&#10;                    IconButton(&#10;                        onClick = {&#10;                            viewMode = if (viewMode == ViewMode.LIST) ViewMode.CALENDAR else ViewMode.LIST&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            if (viewMode == ViewMode.LIST) Icons.Filled.CalendarToday else Icons.AutoMirrored.Filled.List,&#10;                            contentDescription = &quot;Toggle view mode&quot;&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Progress Overview&#10;            if (todos.isNotEmpty()) {&#10;                ProgressOverview(todos = todos)&#10;            }&#10;&#10;            // Search and Filter Row&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = searchQuery,&#10;                    onValueChange = { searchQuery = it },&#10;                    placeholder = { Text(&quot;Search tasks...&quot;) },&#10;                    leadingIcon = { Icon(Icons.Filled.Search, contentDescription = &quot;Search&quot;) },&#10;                    modifier = Modifier.weight(1f),&#10;                    trailingIcon = {&#10;                        if (searchQuery.isNotBlank()) {&#10;                            IconButton(&#10;                                onClick = { searchQuery = &quot;&quot; }&#10;                            ) {&#10;                                Icon(Icons.Filled.Clear, contentDescription = &quot;Clear search&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                IconButton(&#10;                    onClick = { showFilterDialog = true },&#10;                    modifier = Modifier.size(48.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Filled.FilterList,&#10;                        contentDescription = &quot;Filter&quot;,&#10;                        tint = if (selectedCategory != &quot;All&quot; || selectedPriority != &quot;All&quot; || !showCompleted)&#10;                            Color(0xFF4A90E2) else Color.Gray&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Active filters display&#10;            if (selectedCategory != &quot;All&quot; || selectedPriority != &quot;All&quot; || !showCompleted) {&#10;                LazyRow(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    if (selectedCategory != &quot;All&quot;) {&#10;                        item {&#10;                            FilterChip(&#10;                                onClick = { selectedCategory = &quot;All&quot; },&#10;                                label = { Text(&quot;Category: $selectedCategory&quot;) },&#10;                                selected = true,&#10;                                trailingIcon = { Icon(Icons.Filled.Clear, contentDescription = &quot;Remove filter&quot;) }&#10;                            )&#10;                        }&#10;                    }&#10;                    if (selectedPriority != &quot;All&quot;) {&#10;                        item {&#10;                            FilterChip(&#10;                                onClick = { selectedPriority = &quot;All&quot; },&#10;                                label = { Text(&quot;Priority: $selectedPriority&quot;) },&#10;                                selected = true,&#10;                                trailingIcon = { Icon(Icons.Filled.Clear, contentDescription = &quot;Remove filter&quot;) }&#10;                            )&#10;                        }&#10;                    }&#10;                    if (!showCompleted) {&#10;                        item {&#10;                            FilterChip(&#10;                                onClick = { showCompleted = true },&#10;                                label = { Text(&quot;Hide Completed&quot;) },&#10;                                selected = true,&#10;                                trailingIcon = { Icon(Icons.Filled.Clear, contentDescription = &quot;Remove filter&quot;) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;&#10;            // Content based on view mode&#10;            when (viewMode) {&#10;                ViewMode.LIST -&gt; {&#10;                    // Todo List&#10;                    if (filteredTodos.isEmpty()) {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = if (todos.isEmpty()) &quot;No tasks yet. Tap the + button to add your first task!&quot;&#10;                                       else &quot;No tasks match your search or filters.&quot;,&#10;                                color = Color(0xFFBDBDBD),&#10;                                fontSize = 18.sp,&#10;                                lineHeight = 24.sp&#10;                            )&#10;                        }&#10;                    } else {&#10;                        LazyColumn(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentPadding = PaddingValues(vertical = 16.dp)&#10;                        ) {&#10;                            itemsIndexed(filteredTodos) { index, todo -&gt;&#10;                                EnhancedTodoDetailScreen(&#10;                                    todo = todo,&#10;                                    onEdit = {&#10;                                        editingTodo = todo&#10;                                        showEditDialog = true&#10;                                    },&#10;                                    onToggleComplete = {&#10;                                        val updatedTodos = handleTaskCompletion(todos, todo, context)&#10;                                        todos = updatedTodos&#10;                                        // Log activity&#10;                                        val action = if (todo.isDone) &quot;uncompleted&quot; else &quot;completed&quot;&#10;                                        activityLog = activityLog + ActivityLogEntry(&#10;                                            taskId = todo.id,&#10;                                            taskTitle = todo.title,&#10;                                            action = action,&#10;                                            details = &quot;Task $action by user&quot;&#10;                                        )&#10;                                    },&#10;                                    onViewDetails = {&#10;                                        selectedTodoForDetails = todo&#10;                                        showTaskDetailsDialog = true&#10;                                    }&#10;                                )&#10;                                Spacer(modifier = Modifier.height(16.dp))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                ViewMode.CALENDAR -&gt; {&#10;                    CalendarView(todos = filteredTodos)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Dialogs&#10;        if (showAddDialog) {&#10;            AddTodoDialog(&#10;                onAdd = { title: String, notes: String, dueDate: String, category: String, priority: String, isRecurring: Boolean, recurrenceType: RecurrenceType, customInterval: Int -&gt;&#10;                    val newItem = TodoItem(title = title, notes = notes, dueDate = dueDate, category = category, priority = priority, isRecurring = isRecurring, recurrenceType = recurrenceType, customInterval = customInterval)&#10;                    todos = todos + newItem&#10;                    // Log activity&#10;                    activityLog = activityLog + ActivityLogEntry(&#10;                        taskId = newItem.id,&#10;                        taskTitle = newItem.title,&#10;                        action = &quot;created&quot;,&#10;                        details = &quot;New task created with category: $category, priority: $priority&quot;&#10;                    )&#10;                    if (!newItem.isDone &amp;&amp; newItem.dueDate.isNotBlank()) {&#10;                        ReminderScheduler.schedule(context, newItem.id, newItem.title, newItem.notes, newItem.dueDate)&#10;                    }&#10;                    showAddDialog = false&#10;                },&#10;                onDismiss = { showAddDialog = false }&#10;            )&#10;        }&#10;&#10;        if (showEditDialog &amp;&amp; editingTodo != null) {&#10;            val todo = editingTodo!!&#10;            EditTodoDialog(&#10;                initialTitle = todo.title,&#10;                initialNotes = todo.notes,&#10;                initialDueDate = todo.dueDate,&#10;                initialCategory = todo.category,&#10;                initialPriority = todo.priority,&#10;                onEdit = { newTitle: String, newNotes: String, newDueDate: String, newCategory: String, newPriority: String -&gt;&#10;                    todos = todos.map {&#10;                        if (it.id == todo.id) {&#10;                            val updated = it.copy(title = newTitle, notes = newNotes, dueDate = newDueDate, category = newCategory, priority = newPriority)&#10;                            ReminderScheduler.cancel(context, todo.id)&#10;                            if (!updated.isDone &amp;&amp; updated.dueDate.isNotBlank()) {&#10;                                ReminderScheduler.schedule(context, updated.id, updated.title, updated.notes, updated.dueDate)&#10;                            }&#10;                            // Log activity&#10;                            activityLog = activityLog + ActivityLogEntry(&#10;                                taskId = todo.id,&#10;                                taskTitle = newTitle,&#10;                                action = &quot;updated&quot;,&#10;                                details = &quot;Task details modified&quot;&#10;                            )&#10;                            updated&#10;                        } else it&#10;                    }&#10;                    showEditDialog = false&#10;                    editingTodo = null&#10;                },&#10;                onDelete = {&#10;                    ReminderScheduler.cancel(context, todo.id)&#10;                    todos = todos.filter { it.id != todo.id }&#10;                    // Log activity&#10;                    activityLog = activityLog + ActivityLogEntry(&#10;                        taskId = todo.id,&#10;                        taskTitle = todo.title,&#10;                        action = &quot;deleted&quot;,&#10;                        details = &quot;Task permanently deleted&quot;&#10;                    )&#10;                    showEditDialog = false&#10;                    editingTodo = null&#10;                },&#10;                onDismiss = {&#10;                    showEditDialog = false&#10;                    editingTodo = null&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showFilterDialog) {&#10;            FilterDialog(&#10;                currentCategory = selectedCategory,&#10;                currentPriority = selectedPriority,&#10;                showCompleted = showCompleted,&#10;                onCategoryChange = { selectedCategory = it },&#10;                onPriorityChange = { selectedPriority = it },&#10;                onShowCompletedChange = { showCompleted = it },&#10;                onDismiss = { showFilterDialog = false }&#10;            )&#10;        }&#10;&#10;        if (showActivityDialog) {&#10;            ActivityLogDialog(&#10;                activityLog = activityLog,&#10;                onDismiss = { showActivityDialog = false }&#10;            )&#10;        }&#10;&#10;        if (showTaskDetailsDialog &amp;&amp; selectedTodoForDetails != null) {&#10;            TaskDetailsDialog(&#10;                todo = selectedTodoForDetails!!,&#10;                onDismiss = {&#10;                    showTaskDetailsDialog = false&#10;                    selectedTodoForDetails = null&#10;                },&#10;                onAddComment = { comment -&gt;&#10;                    todos = todos.map {&#10;                        if (it.id == selectedTodoForDetails!!.id) {&#10;                            val newComment = TaskComment(text = comment)&#10;                            val updated = it.copy(comments = it.comments + newComment)&#10;                            // Log activity&#10;                            activityLog = activityLog + ActivityLogEntry(&#10;                                taskId = it.id,&#10;                                taskTitle = it.title,&#10;                                action = &quot;comment_added&quot;,&#10;                                details = &quot;Comment added: ${comment.take(50)}${if (comment.length &gt; 50) &quot;...&quot; else &quot;&quot;}&quot;&#10;                            )&#10;                            updated&#10;                        } else it&#10;                    }&#10;                    selectedTodoForDetails = todos.find { it.id == selectedTodoForDetails!!.id }&#10;                },&#10;                onUpdateProgress = { percentage -&gt;&#10;                    todos = todos.map {&#10;                        if (it.id == selectedTodoForDetails!!.id) {&#10;                            val updated = it.copy(completionPercentage = percentage)&#10;                            // Log activity&#10;                            activityLog = activityLog + ActivityLogEntry(&#10;                                taskId = it.id,&#10;                                taskTitle = it.title,&#10;                                action = &quot;progress_updated&quot;,&#10;                                details = &quot;Progress updated to $percentage%&quot;&#10;                            )&#10;                            updated&#10;                        } else it&#10;                    }&#10;                    selectedTodoForDetails = todos.find { it.id == selectedTodoForDetails!!.id }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TodoDetailScreen(&#10;    todo: TodoItem,&#10;    onEdit: () -&gt; Unit,&#10;    onToggleComplete: () -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(top = 32.dp, start = 24.dp, end = 24.dp)&#10;    ) {&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Checkbox(&#10;                checked = todo.isDone,&#10;                onCheckedChange = { onToggleComplete() },&#10;                modifier = Modifier.size(32.dp),&#10;                colors = CheckboxDefaults.colors(&#10;                    checkedColor = Color(0xFF4A90E2),&#10;                    uncheckedColor = Color(0xFF4A90E2),&#10;                    checkmarkColor = Color.White&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(&#10;                text = todo.title,&#10;                fontSize = 32.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color(0xFF222222)&#10;            )&#10;            // Recurring indicator&#10;            if (todo.isRecurring &amp;&amp; todo.recurrenceType != RecurrenceType.NONE) {&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = &quot;&quot;,&#10;                    fontSize = 20.sp,&#10;                    color = Color(0xFF4A90E2)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Column(modifier = Modifier.align(Alignment.CenterVertically)) {&#10;                Text(&#10;                    text = todo.category,&#10;                    color = Color(0xFF4A90E2),&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 2.dp)&#10;                )&#10;                Text(&#10;                    text = todo.priority,&#10;                    color = when (todo.priority) {&#10;                        &quot;High&quot; -&gt; Color.Red&#10;                        &quot;Medium&quot; -&gt; Color(0xFFFFA500)&#10;                        else -&gt; Color(0xFF4CAF50)&#10;                    },&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Medium,&#10;                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 2.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            IconButton(onClick = onEdit) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.MoreVert,&#10;                    contentDescription = &quot;More&quot;,&#10;                    tint = Color(0xFFBDBDBD)&#10;                )&#10;            }&#10;        }&#10;        if (todo.dueDate.isNotBlank()) {&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = &quot;Due: ${todo.dueDate}&quot;,&#10;                color = Color(0xFFBDBDBD),&#10;                fontSize = 16.sp,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;        }&#10;        if (todo.isRecurring &amp;&amp; todo.recurrenceType != RecurrenceType.NONE) {&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = &quot;Repeats: ${getRecurrenceDisplay(todo.recurrenceType, todo.customInterval)}&quot;,&#10;                color = Color(0xFF4A90E2),&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Text(&#10;            text = &quot;Notes&quot;,&#10;            color = Color(0xFFBDBDBD),&#10;            fontSize = 18.sp,&#10;            modifier = Modifier.padding(start = 8.dp, top = 8.dp)&#10;        )&#10;        if (todo.notes.isNotBlank()) {&#10;            Text(&#10;                text = todo.notes,&#10;                color = Color(0xFF757575),&#10;                fontSize = 18.sp,&#10;                modifier = Modifier.padding(start = 8.dp, top = 4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun getRecurrenceDisplay(recurrenceType: RecurrenceType, customInterval: Int): String {&#10;    return when (recurrenceType) {&#10;        RecurrenceType.DAILY -&gt; &quot;Daily&quot;&#10;        RecurrenceType.WEEKLY -&gt; &quot;Weekly&quot;&#10;        RecurrenceType.MONTHLY -&gt; &quot;Monthly&quot;&#10;        RecurrenceType.CUSTOM_DAYS -&gt; &quot;Every $customInterval days&quot;&#10;        RecurrenceType.NONE -&gt; &quot;&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;fun AddTodoDialog(&#10;    onAdd: (title: String, notes: String, dueDate: String, category: String, priority: String, isRecurring: Boolean, recurrenceType: RecurrenceType, customInterval: Int) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var notes by remember { mutableStateOf(&quot;&quot;) }&#10;    var dueDate by remember { mutableStateOf(&quot;&quot;) }&#10;    var category by remember { mutableStateOf(&quot;Personal&quot;) }&#10;    var priority by remember { mutableStateOf(&quot;Medium&quot;) }&#10;    var isRecurring by remember { mutableStateOf(false) }&#10;    var recurrenceType by remember { mutableStateOf(RecurrenceType.DAILY) }&#10;    var customInterval by remember { mutableIntStateOf(1) }&#10;    var showDatePicker by remember { mutableStateOf(false) }&#10;&#10;    val dateFormat = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;    val dueDateDisplay = dueDate&#10;    val today = remember { Calendar.getInstance().apply { set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0) }.timeInMillis }&#10;    val datePickerState = rememberDatePickerState(&#10;        initialDisplayedMonthMillis = today&#10;    )&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;New To-Do&quot;) },&#10;        text = {&#10;            LazyColumn {&#10;                item {&#10;                    OutlinedTextField(&#10;                        value = title,&#10;                        onValueChange = { title = it },&#10;                        label = { Text(&quot;Title&quot;) },&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;                item {&#10;                    OutlinedTextField(&#10;                        value = notes,&#10;                        onValueChange = { notes = it },&#10;                        label = { Text(&quot;Notes&quot;) },&#10;                        modifier = Modifier.padding(top = 8.dp).fillMaxWidth()&#10;                    )&#10;                }&#10;                item {&#10;                    OutlinedTextField(&#10;                        value = dueDateDisplay,&#10;                        onValueChange = {},&#10;                        label = { Text(&quot;Due Date&quot;) },&#10;                        modifier = Modifier&#10;                            .padding(top = 8.dp)&#10;                            .fillMaxWidth()&#10;                            .clickable { showDatePicker = true },&#10;                        readOnly = true,&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { showDatePicker = true }) {&#10;                                Icon(Icons.Filled.Event, contentDescription = &quot;Pick date&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Recurring Task Section&#10;                item {&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(top = 16.dp)&#10;                            .clickable { isRecurring = !isRecurring }&#10;                    ) {&#10;                        Checkbox(&#10;                            checked = isRecurring,&#10;                            onCheckedChange = { isRecurring = it }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&quot;Recurring Task&quot;, fontWeight = FontWeight.Medium)&#10;                    }&#10;                }&#10;&#10;                if (isRecurring) {&#10;                    item {&#10;                        // Recurrence Type Dropdown&#10;                        val recurrenceTypes = listOf(&quot;Daily&quot;, &quot;Weekly&quot;, &quot;Monthly&quot;, &quot;Custom Days&quot;)&#10;                        var expandedRecurrence by remember { mutableStateOf(false) }&#10;                        Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                            OutlinedTextField(&#10;                                value = when (recurrenceType) {&#10;                                    RecurrenceType.DAILY -&gt; &quot;Daily&quot;&#10;                                    RecurrenceType.WEEKLY -&gt; &quot;Weekly&quot;&#10;                                    RecurrenceType.MONTHLY -&gt; &quot;Monthly&quot;&#10;                                    RecurrenceType.CUSTOM_DAYS -&gt; &quot;Custom Days&quot;&#10;                                    else -&gt; &quot;Daily&quot;&#10;                                },&#10;                                onValueChange = {},&#10;                                label = { Text(&quot;Repeat&quot;) },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable { expandedRecurrence = true },&#10;                                readOnly = true,&#10;                                trailingIcon = {&#10;                                    IconButton(onClick = { expandedRecurrence = true }) {&#10;                                        Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select recurrence&quot;)&#10;                                    }&#10;                                }&#10;                            )&#10;                            DropdownMenu(&#10;                                expanded = expandedRecurrence,&#10;                                onDismissRequest = { expandedRecurrence = false }&#10;                            ) {&#10;                                recurrenceTypes.forEachIndexed { index, type -&gt;&#10;                                    DropdownMenuItem(&#10;                                        text = { Text(type) },&#10;                                        onClick = {&#10;                                            recurrenceType = when (index) {&#10;                                                0 -&gt; RecurrenceType.DAILY&#10;                                                1 -&gt; RecurrenceType.WEEKLY&#10;                                                2 -&gt; RecurrenceType.MONTHLY&#10;                                                3 -&gt; RecurrenceType.CUSTOM_DAYS&#10;                                                else -&gt; RecurrenceType.DAILY&#10;                                            }&#10;                                            expandedRecurrence = false&#10;                                        }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    if (recurrenceType == RecurrenceType.CUSTOM_DAYS) {&#10;                        item {&#10;                            OutlinedTextField(&#10;                                value = customInterval.toString(),&#10;                                onValueChange = {&#10;                                    val newValue = it.toIntOrNull()&#10;                                    if (newValue != null &amp;&amp; newValue &gt; 0) {&#10;                                        customInterval = newValue&#10;                                    }&#10;                                },&#10;                                label = { Text(&quot;Every X days&quot;) },&#10;                                modifier = Modifier.padding(top = 8.dp).fillMaxWidth(),&#10;                                singleLine = true&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Category Dropdown&#10;                item {&#10;                    val categories = listOf(&quot;Personal&quot;, &quot;Work&quot;, &quot;School&quot;)&#10;                    var expanded by remember { mutableStateOf(false) }&#10;                    Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                        OutlinedTextField(&#10;                            value = category,&#10;                            onValueChange = {},&#10;                            label = { Text(&quot;Category&quot;) },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { expanded = true },&#10;                            readOnly = true,&#10;                            trailingIcon = {&#10;                                IconButton(onClick = { expanded = true }) {&#10;                                    Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select category&quot;)&#10;                                }&#10;                            }&#10;                        )&#10;                        DropdownMenu(&#10;                            expanded = expanded,&#10;                            onDismissRequest = { expanded = false }&#10;                        ) {&#10;                            categories.forEach { cat -&gt;&#10;                                DropdownMenuItem(&#10;                                    text = { Text(cat) },&#10;                                    onClick = {&#10;                                        category = cat&#10;                                        expanded = false&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Priority Dropdown&#10;                item {&#10;                    val priorities = listOf(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)&#10;                    var expandedPriority by remember { mutableStateOf(false) }&#10;                    Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                        OutlinedTextField(&#10;                            value = priority,&#10;                            onValueChange = {},&#10;                            label = { Text(&quot;Priority&quot;) },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { expandedPriority = true },&#10;                            readOnly = true,&#10;                            trailingIcon = {&#10;                                IconButton(onClick = { expandedPriority = true }) {&#10;                                    Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select priority&quot;)&#10;                                }&#10;                            }&#10;                        )&#10;                        DropdownMenu(&#10;                            expanded = expandedPriority,&#10;                            onDismissRequest = { expandedPriority = false }&#10;                        ) {&#10;                            priorities.forEach { p -&gt;&#10;                                DropdownMenuItem(&#10;                                    text = { Text(p) },&#10;                                    onClick = {&#10;                                        priority = p&#10;                                        expandedPriority = false&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(&#10;                onClick = {&#10;                    if (title.isNotBlank()) {&#10;                        onAdd(&#10;                            title,&#10;                            notes,&#10;                            dueDate,&#10;                            category,&#10;                            priority,&#10;                            isRecurring,&#10;                            if (isRecurring) recurrenceType else RecurrenceType.NONE,&#10;                            customInterval&#10;                        )&#10;                    }&#10;                }&#10;            ) { Text(&quot;Add&quot;) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cancel&quot;) }&#10;        }&#10;    )&#10;&#10;    var showWarning by remember { mutableStateOf(false) }&#10;    if (showDatePicker) {&#10;        DatePickerDialog(&#10;            onDismissRequest = { showDatePicker = false },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    val millis = datePickerState.selectedDateMillis&#10;                    if (millis != null &amp;&amp; millis &gt;= today) {&#10;                        dueDate = dateFormat.format(Date(millis))&#10;                        showDatePicker = false&#10;                    } else {&#10;                        showWarning = true&#10;                    }&#10;                }) { Text(&quot;OK&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showDatePicker = false }) { Text(&quot;Cancel&quot;) }&#10;            }&#10;        ) {&#10;            CustomDatePicker(state = datePickerState)&#10;        }&#10;    }&#10;    if (showWarning) {&#10;        AlertDialog(&#10;            onDismissRequest = { showWarning = false },&#10;            title = { Text(&quot;Invalid Date&quot;) },&#10;            text = { Text(&quot;You cannot select a past date. Please choose today or a future date.&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = { showWarning = false }) { Text(&quot;OK&quot;) }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;fun EditTodoDialog(&#10;    initialTitle: String,&#10;    initialNotes: String,&#10;    initialDueDate: String,&#10;    initialCategory: String,&#10;    initialPriority: String,&#10;    onEdit: (newTitle: String, newNotes: String, newDueDate: String, newCategory: String, newPriority: String) -&gt; Unit,&#10;    onDelete: () -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    var title by remember { mutableStateOf(initialTitle) }&#10;    var notes by remember { mutableStateOf(initialNotes) }&#10;    var dueDate by remember { mutableStateOf(initialDueDate) }&#10;    var category by remember { mutableStateOf(initialCategory) }&#10;    var priority by remember { mutableStateOf(initialPriority) }&#10;    var showDatePicker by remember { mutableStateOf(false) }&#10;&#10;    val dateFormat = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;    val dueDateDisplay = dueDate&#10;    val today = remember { Calendar.getInstance().apply { set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0) }.timeInMillis }&#10;    val datePickerState = rememberDatePickerState(&#10;        initialSelectedDateMillis = try { dateFormat.parse(initialDueDate)?.time } catch (_: Exception) { null },&#10;        initialDisplayedMonthMillis = today&#10;    )&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Edit To-Do&quot;) },&#10;        text = {&#10;            Column {&#10;                OutlinedTextField(&#10;                    value = title,&#10;                    onValueChange = { title = it },&#10;                    label = { Text(&quot;Title&quot;) },&#10;                    singleLine = true&#10;                )&#10;                OutlinedTextField(&#10;                    value = notes,&#10;                    onValueChange = { notes = it },&#10;                    label = { Text(&quot;Notes&quot;) },&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;                OutlinedTextField(&#10;                    value = dueDateDisplay,&#10;                    onValueChange = {},&#10;                    label = { Text(&quot;Due Date&quot;) },&#10;                    modifier = Modifier&#10;                        .padding(top = 8.dp)&#10;                        .clickable { showDatePicker = true },&#10;                    readOnly = true,&#10;                    trailingIcon = {&#10;                        IconButton(onClick = { showDatePicker = true }) {&#10;                            Icon(Icons.Filled.Event, contentDescription = &quot;Pick date&quot;)&#10;                        }&#10;                    }&#10;                )&#10;                var showWarning by remember { mutableStateOf(false) }&#10;                if (showDatePicker) {&#10;                    DatePickerDialog(&#10;                        onDismissRequest = { showDatePicker = false },&#10;                        confirmButton = {&#10;                            TextButton(onClick = {&#10;                                val millis = datePickerState.selectedDateMillis&#10;                                if (millis != null &amp;&amp; millis &gt;= today) {&#10;                                    dueDate = dateFormat.format(Date(millis))&#10;                                    showDatePicker = false&#10;                                } else {&#10;                                    showWarning = true&#10;                                }&#10;                            }) { Text(&quot;OK&quot;) }&#10;                        },&#10;                        dismissButton = {&#10;                            TextButton(onClick = { showDatePicker = false }) { Text(&quot;Cancel&quot;) }&#10;                        }&#10;                    ) {&#10;                        CustomDatePicker(state = datePickerState)&#10;                    }&#10;                }&#10;                if (showWarning) {&#10;                    AlertDialog(&#10;                        onDismissRequest = { showWarning = false },&#10;                        title = { Text(&quot;Invalid Date&quot;) },&#10;                        text = { Text(&quot;You cannot select a past date. Please choose today or a future date.&quot;) },&#10;                        confirmButton = {&#10;                            TextButton(onClick = { showWarning = false }) { Text(&quot;OK&quot;) }&#10;                        }&#10;                    )&#10;                }&#10;                // Category Dropdown&#10;                val categories = listOf(&quot;Personal&quot;, &quot;Work&quot;, &quot;School&quot;)&#10;                var expanded by remember { mutableStateOf(false) }&#10;                Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                    OutlinedTextField(&#10;                        value = category,&#10;                        onValueChange = {},&#10;                        label = { Text(&quot;Category&quot;) },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { expanded = true },&#10;                        readOnly = true,&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { expanded = true }) {&#10;                                Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select category&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                    DropdownMenu(&#10;                        expanded = expanded,&#10;                        onDismissRequest = { expanded = false }&#10;                    ) {&#10;                        categories.forEach { cat -&gt;&#10;                            DropdownMenuItem(&#10;                                text = { Text(cat) },&#10;                                onClick = {&#10;                                    category = cat&#10;                                    expanded = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                // Priority Dropdown&#10;                val priorities = listOf(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)&#10;                var expandedPriority by remember { mutableStateOf(false) }&#10;                Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                    OutlinedTextField(&#10;                        value = priority,&#10;                        onValueChange = {},&#10;                        label = { Text(&quot;Priority&quot;) },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { expandedPriority = true },&#10;                        readOnly = true,&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { expandedPriority = true }) {&#10;                                Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select priority&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                    DropdownMenu(&#10;                        expanded = expandedPriority,&#10;                        onDismissRequest = { expandedPriority = false }&#10;                    ) {&#10;                        priorities.forEach { p -&gt;&#10;                            DropdownMenuItem(&#10;                                text = { Text(p) },&#10;                                onClick = {&#10;                                    priority = p&#10;                                    expandedPriority = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Row {&#10;                TextButton(&#10;                    onClick = {&#10;                        if (title.isNotBlank()) onEdit(title, notes, dueDate, category, priority)&#10;                    }&#10;                ) { Text(&quot;Save&quot;) }&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                TextButton(&#10;                    onClick = onDelete&#10;                ) { Text(&quot;Delete&quot;, color = Color.Red) }&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cancel&quot;) }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun FilterDialog(&#10;    currentCategory: String,&#10;    currentPriority: String,&#10;    showCompleted: Boolean,&#10;    onCategoryChange: (String) -&gt; Unit,&#10;    onPriorityChange: (String) -&gt; Unit,&#10;    onShowCompletedChange: (Boolean) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Filter Tasks&quot;) },&#10;        text = {&#10;            Column {&#10;                // Category Filter&#10;                Text(&quot;Category&quot;, fontWeight = FontWeight.Medium)&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                val categories = listOf(&quot;All&quot;, &quot;Personal&quot;, &quot;Work&quot;, &quot;School&quot;)&#10;                categories.forEach { category -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onCategoryChange(category) }&#10;                            .padding(vertical = 4.dp)&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = currentCategory == category,&#10;                            onClick = { onCategoryChange(category) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(category)&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Priority Filter&#10;                Text(&quot;Priority&quot;, fontWeight = FontWeight.Medium)&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                val priorities = listOf(&quot;All&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)&#10;                priorities.forEach { priority -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onPriorityChange(priority) }&#10;                            .padding(vertical = 4.dp)&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = currentPriority == priority,&#10;                            onClick = { onPriorityChange(priority) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(priority)&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Show Completed Toggle&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { onShowCompletedChange(!showCompleted) }&#10;                        .padding(vertical = 4.dp)&#10;                ) {&#10;                    Checkbox(&#10;                        checked = showCompleted,&#10;                        onCheckedChange = onShowCompletedChange&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&quot;Show completed tasks&quot;)&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Done&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = {&#10;                onCategoryChange(&quot;All&quot;)&#10;                onPriorityChange(&quot;All&quot;)&#10;                onShowCompletedChange(true)&#10;            }) {&#10;                Text(&quot;Clear All&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;fun CustomDatePicker(state: DatePickerState) {&#10;    Box {&#10;        DatePicker(state = state)&#10;    }&#10;}&#10;&#10;&#10;// Utility function to handle task completion and recurring task logic&#10;fun handleTaskCompletion(todos: List&lt;TodoItem&gt;, completedTodo: TodoItem, context: Context): List&lt;TodoItem&gt; {&#10;    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    val today = dateFormat.format(Date())&#10;&#10;    return todos.map { todo -&gt;&#10;        if (todo.id == completedTodo.id) {&#10;            val toggled = todo.copy(&#10;                isDone = !todo.isDone,&#10;                lastCompleted = if (!todo.isDone) today else &quot;&quot;&#10;            )&#10;&#10;            // Handle reminders&#10;            if (toggled.isDone) {&#10;                ReminderScheduler.cancel(context, toggled.id)&#10;            } else if (toggled.dueDate.isNotBlank()) {&#10;                ReminderScheduler.schedule(context, toggled.id, toggled.title, toggled.notes, toggled.dueDate)&#10;            }&#10;&#10;            toggled&#10;        } else {&#10;            todo&#10;        }&#10;    }.let { updatedTodos -&gt;&#10;        // If completing a recurring task, create the next instance&#10;        val completedTask = updatedTodos.find { it.id == completedTodo.id }&#10;        if (completedTask?.isDone == true &amp;&amp; completedTask.isRecurring &amp;&amp; completedTask.recurrenceType != RecurrenceType.NONE) {&#10;            val nextDueDate = calculateNextDueDate(completedTask.dueDate, completedTask.recurrenceType, completedTask.customInterval)&#10;            if (nextDueDate.isNotBlank()) {&#10;                val nextTask = completedTask.copy(&#10;                    id = UUID.randomUUID().toString(),&#10;                    isDone = false,&#10;                    dueDate = nextDueDate,&#10;                    lastCompleted = &quot;&quot;,&#10;                    originalId = completedTask.originalId.ifBlank { completedTask.id }&#10;                )&#10;&#10;                // Schedule reminder for the new instance&#10;                ReminderScheduler.schedule(context, nextTask.id, nextTask.title, nextTask.notes, nextTask.dueDate)&#10;&#10;                updatedTodos + nextTask&#10;            } else {&#10;                updatedTodos&#10;            }&#10;        } else {&#10;            updatedTodos&#10;        }&#10;    }&#10;}&#10;&#10;// Calculate the next due date based on recurrence type&#10;fun calculateNextDueDate(currentDueDate: String, recurrenceType: RecurrenceType, customInterval: Int): String {&#10;    if (currentDueDate.isBlank()) return &quot;&quot;&#10;&#10;    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    return try {&#10;        val currentDate = dateFormat.parse(currentDueDate) ?: return &quot;&quot;&#10;        val calendar = Calendar.getInstance().apply { time = currentDate }&#10;&#10;        when (recurrenceType) {&#10;            RecurrenceType.DAILY -&gt; calendar.add(Calendar.DAY_OF_MONTH, 1)&#10;            RecurrenceType.WEEKLY -&gt; calendar.add(Calendar.WEEK_OF_YEAR, 1)&#10;            RecurrenceType.MONTHLY -&gt; calendar.add(Calendar.MONTH, 1)&#10;            RecurrenceType.CUSTOM_DAYS -&gt; calendar.add(Calendar.DAY_OF_MONTH, customInterval)&#10;            RecurrenceType.NONE -&gt; return &quot;&quot;&#10;        }&#10;&#10;        dateFormat.format(calendar.time)&#10;    } catch (_: Exception) {&#10;        &quot;&quot;&#10;    }&#10;}&#10;&#10;// Progress Overview component&#10;@Composable&#10;fun ProgressOverview(todos: List&lt;TodoItem&gt;) {&#10;    val totalTasks = todos.size&#10;    val completedTasks = todos.count { it.isDone }&#10;    val completionPercentage = if (totalTasks &gt; 0) (completedTasks * 100) / totalTasks else 0&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFFF5F5F5))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Progress Overview&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;                Text(&#10;                    text = &quot;$completedTasks/$totalTasks completed&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF757575)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            LinearProgressIndicator(&#10;                progress = { completionPercentage / 100f },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(8.dp)&#10;                    .clip(RoundedCornerShape(4.dp)),&#10;                color = Color(0xFF4A90E2),&#10;                trackColor = Color(0xFFE0E0E0),&#10;                strokeCap = StrokeCap.Round&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Text(&#10;                text = &quot;$completionPercentage% Complete&quot;,&#10;                fontSize = 14.sp,&#10;                color = Color(0xFF4A90E2),&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainScreenPreview() {&#10;    ToDoTheme {&#10;        MainScreen()&#10;    }&#10;}&#10;&#10;// Enhanced Todo Detail Screen with progress tracking and additional features&#10;@Composable&#10;fun EnhancedTodoDetailScreen(&#10;    todo: TodoItem,&#10;    onEdit: () -&gt; Unit,&#10;    onToggleComplete: () -&gt; Unit,&#10;    onViewDetails: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp)&#10;            .clickable { onViewDetails() },&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (todo.isDone) Color(0xFFF5F5F5) else Color.White&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Checkbox(&#10;                    checked = todo.isDone,&#10;                    onCheckedChange = { onToggleComplete() },&#10;                    colors = CheckboxDefaults.colors(&#10;                        checkedColor = Color(0xFF4A90E2),&#10;                        uncheckedColor = Color(0xFF4A90E2),&#10;                        checkmarkColor = Color.White&#10;                    )&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Text(&#10;                            text = todo.title,&#10;                            fontSize = 18.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = if (todo.isDone) Color(0xFF757575) else Color(0xFF222222)&#10;                        )&#10;&#10;                        if (todo.isRecurring &amp;&amp; todo.recurrenceType != RecurrenceType.NONE) {&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = &quot;&quot;,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF4A90E2)&#10;                            )&#10;                        }&#10;&#10;                        if (todo.comments.isNotEmpty()) {&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Icon(&#10;                                Icons.AutoMirrored.Filled.Comment,&#10;                                contentDescription = &quot;Has comments&quot;,&#10;                                tint = Color(0xFF4A90E2),&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    if (todo.notes.isNotBlank()) {&#10;                        Text(&#10;                            text = todo.notes,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF757575),&#10;                            maxLines = 2,&#10;                            modifier = Modifier.padding(top = 4.dp)&#10;                        )&#10;                    }&#10;&#10;                    // Progress bar for individual task progress&#10;                    if (todo.completionPercentage &gt; 0 &amp;&amp; !todo.isDone) {&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            LinearProgressIndicator(&#10;                                progress = { todo.completionPercentage / 100f },&#10;                                modifier = Modifier&#10;                                    .weight(1f)&#10;                                    .height(6.dp)&#10;                                    .clip(RoundedCornerShape(3.dp)),&#10;                                color = Color(0xFF4A90E2),&#10;                                trackColor = Color(0xFFE0E0E0)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = &quot;${todo.completionPercentage}%&quot;,&#10;                                fontSize = 12.sp,&#10;                                color = Color(0xFF4A90E2),&#10;                                fontWeight = FontWeight.Medium&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Column(horizontalAlignment = Alignment.End) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        // Category badge&#10;                        Surface(&#10;                            color = Color(0xFF4A90E2).copy(alpha = 0.1f),&#10;                            shape = RoundedCornerShape(12.dp),&#10;                            modifier = Modifier.padding(end = 4.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = todo.category,&#10;                                fontSize = 12.sp,&#10;                                color = Color(0xFF4A90E2),&#10;                                fontWeight = FontWeight.Medium,&#10;                                modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;                            )&#10;                        }&#10;&#10;                        // Priority indicator&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(8.dp)&#10;                                .background(&#10;                                    color = when (todo.priority) {&#10;                                        &quot;High&quot; -&gt; Color.Red&#10;                                        &quot;Medium&quot; -&gt; Color(0xFFFFA500)&#10;                                        else -&gt; Color(0xFF4CAF50)&#10;                                    },&#10;                                    shape = CircleShape&#10;                                )&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                        IconButton(onClick = onEdit) {&#10;                            Icon(&#10;                                Icons.Filled.MoreVert,&#10;                                contentDescription = &quot;More options&quot;,&#10;                                tint = Color(0xFFBDBDBD)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    if (todo.dueDate.isNotBlank()) {&#10;                        Text(&#10;                            text = &quot;Due: ${todo.dueDate}&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF757575),&#10;                            modifier = Modifier.padding(top = 4.dp, end = 12.dp)&#10;                        )&#10;                    }&#10;&#10;                    if (todo.streak &gt; 0) {&#10;                        Text(&#10;                            text = &quot; ${todo.streak} day streak&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFFFF5722),&#10;                            fontWeight = FontWeight.Medium,&#10;                            modifier = Modifier.padding(top = 4.dp, end = 12.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Calendar View component&#10;@Composable&#10;fun CalendarView(todos: List&lt;TodoItem&gt;) {&#10;    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    val calendar = Calendar.getInstance()&#10;    val currentMonth = calendar.get(Calendar.MONTH)&#10;    val currentYear = calendar.get(Calendar.YEAR)&#10;&#10;    // Group todos by date&#10;    val todosByDate = remember(todos) {&#10;        todos.filter { it.dueDate.isNotBlank() }&#10;             .groupBy { it.dueDate }&#10;    }&#10;&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        item {&#10;            Text(&#10;                text = &quot;Calendar View&quot;,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier.padding(bottom = 16.dp)&#10;            )&#10;        }&#10;&#10;        // Generate days for current month&#10;        val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;        calendar.set(Calendar.DAY_OF_MONTH, 1)&#10;        val firstDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1&#10;&#10;        // Days of week header&#10;        item {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                listOf(&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;).forEach { day -&gt;&#10;                    Text(&#10;                        text = day,&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        modifier = Modifier.weight(1f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;&#10;        // Calendar grid&#10;        val totalCells = ((daysInMonth + firstDayOfWeek + 6) / 7) * 7&#10;        items(totalCells / 7) { week -&gt;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                repeat(7) { dayOfWeek -&gt;&#10;                    val cellIndex = week * 7 + dayOfWeek&#10;                    val dayOfMonth = cellIndex - firstDayOfWeek + 1&#10;&#10;                    if (dayOfMonth in 1..daysInMonth) {&#10;                        val dateString = String.format(&quot;%04d-%02d-%02d&quot;, currentYear, currentMonth + 1, dayOfMonth)&#10;                        val todosForDay = todosByDate[dateString] ?: emptyList()&#10;&#10;                        CalendarDayCell(&#10;                            dayOfMonth = dayOfMonth,&#10;                            todos = todosForDay,&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    } else {&#10;                        Spacer(modifier = Modifier.weight(1f))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Today's tasks section&#10;        item {&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;            Text(&#10;                text = &quot;Today's Tasks&quot;,&#10;                fontSize = 18.sp,&#10;                fontWeight = FontWeight.SemiBold,&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;        }&#10;&#10;        val today = dateFormat.format(Date())&#10;        val todayTasks = todosByDate[today] ?: emptyList()&#10;&#10;        if (todayTasks.isEmpty()) {&#10;            item {&#10;                Text(&#10;                    text = &quot;No tasks for today&quot;,&#10;                    color = Color(0xFF757575),&#10;                    modifier = Modifier.padding(vertical = 8.dp)&#10;                )&#10;            }&#10;        } else {&#10;            items(todayTasks) { todo -&gt;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 4.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = if (todo.isDone) Color(0xFFF5F5F5) else Color.White&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(12.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = if (todo.isDone) &quot;&quot; else &quot;&quot;,&#10;                            fontSize = 16.sp,&#10;                            color = if (todo.isDone) Color(0xFF4CAF50) else Color(0xFF757575)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(12.dp))&#10;                        Text(&#10;                            text = todo.title,&#10;                            fontSize = 16.sp,&#10;                            color = if (todo.isDone) Color(0xFF757575) else Color(0xFF222222)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CalendarDayCell(&#10;    dayOfMonth: Int,&#10;    todos: List&lt;TodoItem&gt;,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .padding(2.dp)&#10;            .background(&#10;                color = if (todos.isNotEmpty()) Color(0xFF4A90E2).copy(alpha = 0.1f) else Color.Transparent,&#10;                shape = RoundedCornerShape(4.dp)&#10;            ),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = dayOfMonth.toString(),&#10;                fontSize = 14.sp,&#10;                color = Color(0xFF222222)&#10;            )&#10;            if (todos.isNotEmpty()) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(6.dp)&#10;                        .background(Color(0xFF4A90E2), CircleShape)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Activity Log Dialog component&#10;@Composable&#10;fun ActivityLogDialog(&#10;    activityLog: List&lt;ActivityLogEntry&gt;,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Icon(Icons.Filled.History, contentDescription = &quot;Activity Log&quot;)&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&quot;Activity Log&quot;)&#10;            }&#10;        },&#10;        text = {&#10;            if (activityLog.isEmpty()) {&#10;                Text(&quot;No activity yet. Start creating and managing tasks to see your activity here!&quot;)&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(400.dp)&#10;                ) {&#10;                    items(activityLog.sortedByDescending { it.timestamp }) { entry -&gt;&#10;                        ActivityLogItem(entry)&#10;                        if (entry != activityLog.last()) {&#10;                            Divider(modifier = Modifier.padding(vertical = 4.dp))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Close&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun ActivityLogItem(entry: ActivityLogEntry) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = entry.taskTitle,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    val actionIcon = when (entry.action) {&#10;                        &quot;created&quot; -&gt; &quot;&quot;&#10;                        &quot;completed&quot; -&gt; &quot;&quot;&#10;                        &quot;uncompleted&quot; -&gt; &quot;&quot;&#10;                        &quot;updated&quot; -&gt; &quot;&quot;&#10;                        &quot;deleted&quot; -&gt; &quot;&quot;&#10;                        &quot;comment_added&quot; -&gt; &quot;&quot;&#10;                        &quot;progress_updated&quot; -&gt; &quot;&quot;&#10;                        else -&gt; &quot;&quot;&#10;                    }&#10;                    Text(&#10;                        text = actionIcon,&#10;                        fontSize = 14.sp,&#10;                        modifier = Modifier.padding(end = 4.dp)&#10;                    )&#10;                    Text(&#10;                        text = entry.action.replace(&quot;_&quot;, &quot; &quot;).replaceFirstChar {&#10;                            if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString()&#10;                        },&#10;                        fontSize = 14.sp,&#10;                        color = Color(0xFF4A90E2),&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                }&#10;                if (entry.details.isNotBlank()) {&#10;                    Text(&#10;                        text = entry.details,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF757575),&#10;                        modifier = Modifier.padding(top = 2.dp)&#10;                    )&#10;                }&#10;            }&#10;            Text(&#10;                text = formatTimestamp(entry.timestamp),&#10;                fontSize = 12.sp,&#10;                color = Color(0xFF757575)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// Task Details Dialog component&#10;@Composable&#10;fun TaskDetailsDialog(&#10;    todo: TodoItem,&#10;    onDismiss: () -&gt; Unit,&#10;    onAddComment: (String) -&gt; Unit,&#10;    onUpdateProgress: (Int) -&gt; Unit&#10;) {&#10;    var newComment by remember { mutableStateOf(&quot;&quot;) }&#10;    var progressValue by remember { mutableIntStateOf(todo.completionPercentage) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Icon(Icons.Filled.Timeline, contentDescription = &quot;Task Details&quot;)&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&quot;Task Details&quot;)&#10;            }&#10;        },&#10;        text = {&#10;            LazyColumn(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(500.dp)&#10;            ) {&#10;                // Task Info&#10;                item {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = CardDefaults.cardColors(containerColor = Color(0xFFF5F5F5))&#10;                    ) {&#10;                        Column(modifier = Modifier.padding(16.dp)) {&#10;                            Text(&#10;                                text = todo.title,&#10;                                fontSize = 18.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;                            if (todo.notes.isNotBlank()) {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Text(&#10;                                    text = todo.notes,&#10;                                    fontSize = 14.sp,&#10;                                    color = Color(0xFF757575)&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                            // Progress Section&#10;                            Text(&#10;                                text = &quot;Progress&quot;,&#10;                                fontSize = 16.sp,&#10;                                fontWeight = FontWeight.SemiBold&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                            Slider(&#10;                                value = progressValue.toFloat(),&#10;                                onValueChange = { progressValue = it.toInt() },&#10;                                valueRange = 0f..100f,&#10;                                steps = 19, // 5% increments&#10;                                modifier = Modifier.fillMaxWidth()&#10;                            )&#10;                            Text(&#10;                                text = &quot;$progressValue% Complete&quot;,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFF4A90E2),&#10;                                textAlign = TextAlign.Center,&#10;                                modifier = Modifier.fillMaxWidth()&#10;                            )&#10;&#10;                            if (progressValue != todo.completionPercentage) {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Button(&#10;                                    onClick = {&#10;                                        onUpdateProgress(progressValue)&#10;                                    },&#10;                                    modifier = Modifier.fillMaxWidth()&#10;                                ) {&#10;                                    Text(&quot;Update Progress&quot;)&#10;                                }&#10;                            }&#10;&#10;                            // Task Stats&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Divider()&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween&#10;                            ) {&#10;                                Column {&#10;                                    Text(&quot;Category&quot;, fontSize = 12.sp, color = Color(0xFF757575))&#10;                                    Text(todo.category, fontSize = 14.sp, fontWeight = FontWeight.Medium)&#10;                                }&#10;                                Column {&#10;                                    Text(&quot;Priority&quot;, fontSize = 12.sp, color = Color(0xFF757575))&#10;                                    Text(&#10;                                        text = todo.priority,&#10;                                        fontSize = 14.sp,&#10;                                        fontWeight = FontWeight.Medium,&#10;                                        color = when (todo.priority) {&#10;                                            &quot;High&quot; -&gt; Color.Red&#10;                                            &quot;Medium&quot; -&gt; Color(0xFFFFA500)&#10;                                            else -&gt; Color(0xFF4CAF50)&#10;                                        }&#10;                                    )&#10;                                }&#10;                                if (todo.streak &gt; 0) {&#10;                                    Column {&#10;                                        Text(&quot;Streak&quot;, fontSize = 12.sp, color = Color(0xFF757575))&#10;                                        Text(&quot; ${todo.streak}&quot;, fontSize = 14.sp, fontWeight = FontWeight.Medium)&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            if (todo.dueDate.isNotBlank()) {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Text(&quot;Due Date&quot;, fontSize = 12.sp, color = Color(0xFF757575))&#10;                                Text(todo.dueDate, fontSize = 14.sp, fontWeight = FontWeight.Medium)&#10;                            }&#10;                        }&#10;                    }&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;&#10;                // Comments Section&#10;                item {&#10;                    Text(&#10;                        text = &quot;Comments (${todo.comments.size})&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    // Add comment&#10;                    OutlinedTextField(&#10;                        value = newComment,&#10;                        onValueChange = { newComment = it },&#10;                        placeholder = { Text(&quot;Add a comment...&quot;) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        trailingIcon = {&#10;                            IconButton(&#10;                                onClick = {&#10;                                    if (newComment.isNotBlank()) {&#10;                                        onAddComment(newComment)&#10;                                        newComment = &quot;&quot;&#10;                                    }&#10;                                }&#10;                            ) {&#10;                                Icon(Icons.AutoMirrored.Filled.Comment, contentDescription = &quot;Add comment&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                }&#10;&#10;                // Comments list&#10;                if (todo.comments.isEmpty()) {&#10;                    item {&#10;                        Text(&#10;                            text = &quot;No comments yet. Add one above!&quot;,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF757575),&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    }&#10;                } else {&#10;                    items(todo.comments.sortedByDescending { it.timestamp }) { comment -&gt;&#10;                        CommentItem(comment)&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                    }&#10;                }&#10;&#10;                // Attachments Section (placeholder for future implementation)&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Attachments (${todo.attachments.size})&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    if (todo.attachments.isEmpty()) {&#10;                        Text(&#10;                            text = &quot;No attachments&quot;,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF757575)&#10;                        )&#10;                    } else {&#10;                        // Placeholder for attachments display&#10;                        todo.attachments.forEach { attachment -&gt;&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFFF8F8F8))&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier.padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        Icons.Filled.Attachment,&#10;                                        contentDescription = &quot;Attachment&quot;,&#10;                                        tint = Color(0xFF4A90E2)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Column {&#10;                                        Text(attachment.name, fontWeight = FontWeight.Medium)&#10;                                        Text(&#10;                                            attachment.type,&#10;                                            fontSize = 12.sp,&#10;                                            color = Color(0xFF757575)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Close&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun CommentItem(comment: TaskComment) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFFF8F8F8))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;&quot;,&#10;                    fontSize = 16.sp&#10;                )&#10;                Text(&#10;                    text = formatTimestamp(comment.timestamp),&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF757575)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = comment.text,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// Utility function to format timestamps&#10;fun formatTimestamp(timestamp: String): String {&#10;    return try {&#10;        val sdf = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;        val date = sdf.parse(timestamp)&#10;        val now = Date()&#10;        val diffInMs = now.time - (date?.time ?: 0)&#10;        val diffInMinutes = diffInMs / (1000 * 60)&#10;        val diffInHours = diffInMs / (1000 * 60 * 60)&#10;        val diffInDays = diffInMs / (1000 * 60 * 60 * 24)&#10;&#10;        when {&#10;            diffInMinutes &lt; 1 -&gt; &quot;Just now&quot;&#10;            diffInMinutes &lt; 60 -&gt; &quot;${diffInMinutes}m ago&quot;&#10;            diffInHours &lt; 24 -&gt; &quot;${diffInHours}h ago&quot;&#10;            diffInDays &lt; 7 -&gt; &quot;${diffInDays}d ago&quot;&#10;            else -&gt; {&#10;                val displaySdf = SimpleDateFormat(&quot;MMM dd&quot;, Locale.getDefault())&#10;                displaySdf.format(date ?: Date())&#10;            }&#10;        }&#10;    } catch (e: Exception) {&#10;        &quot;Unknown&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.todo&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.Comment&#10;import androidx.compose.material.icons.automirrored.filled.List&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Attachment&#10;import androidx.compose.material.icons.filled.CalendarToday&#10;import androidx.compose.material.icons.filled.Clear&#10;import androidx.compose.material.icons.filled.DarkMode&#10;import androidx.compose.material.icons.filled.Event&#10;import androidx.compose.material.icons.filled.FilterList&#10;import androidx.compose.material.icons.filled.History&#10;import androidx.compose.material.icons.filled.LightMode&#10;import androidx.compose.material.icons.filled.MoreVert&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material.icons.filled.Timeline&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.DatePicker&#10;import androidx.compose.material3.DatePickerDialog&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.core.content.ContextCompat&#10;import com.example.todo.ui.theme.ToDoTheme&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;// Data model now includes a stable id to map reminders to tasks and recurring task support&#10;&#10;data class TodoItem(&#10;    val title: String,&#10;    val notes: String = &quot;&quot;,&#10;    val isDone: Boolean = false,&#10;    val dueDate: String = &quot;&quot;,&#10;    val category: String = &quot;Personal&quot;,&#10;    val priority: String = &quot;Medium&quot;,&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val isRecurring: Boolean = false,&#10;    val recurrenceType: RecurrenceType = RecurrenceType.NONE,&#10;    val customInterval: Int = 1, // for custom intervals (e.g., every 3 days)&#10;    val lastCompleted: String = &quot;&quot;, // track when last completed for recurring tasks&#10;    val originalId: String = &quot;&quot;, // to link recurring instances to original task&#10;    val createdDate: String = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date()),&#10;    val completedDate: String = &quot;&quot;,&#10;    val completionPercentage: Int = 0, // 0-100 for progress tracking&#10;    val comments: List&lt;TaskComment&gt; = emptyList(),&#10;    val attachments: List&lt;TaskAttachment&gt; = emptyList(),&#10;    val streak: Int = 0 // for recurring tasks&#10;)&#10;&#10;data class TaskComment(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val text: String,&#10;    val timestamp: String = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;)&#10;&#10;data class TaskAttachment(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val name: String,&#10;    val type: String, // &quot;image&quot;, &quot;document&quot;, &quot;link&quot;&#10;    val uri: String,&#10;    val timestamp: String = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;)&#10;&#10;data class ActivityLogEntry(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val taskId: String,&#10;    val taskTitle: String,&#10;    val action: String, // &quot;created&quot;, &quot;completed&quot;, &quot;updated&quot;, &quot;deleted&quot;, &quot;comment_added&quot;, etc.&#10;    val details: String = &quot;&quot;,&#10;    val timestamp: String = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;)&#10;&#10;enum class RecurrenceType {&#10;    NONE,&#10;    DAILY,&#10;    WEEKLY,&#10;    MONTHLY,&#10;    CUSTOM_DAYS&#10;}&#10;&#10;enum class ViewMode {&#10;    LIST,&#10;    CALENDAR&#10;}&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            ToDoTheme {&#10;                MainScreen()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnsureNotificationPermission() {&#10;    val context = LocalContext.current&#10;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;        val permission = Manifest.permission.POST_NOTIFICATIONS&#10;        val launcher = rememberLauncherForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { /* no-op */ }&#10;        LaunchedEffect(Unit) {&#10;            val granted = ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED&#10;            if (!granted) launcher.launch(permission)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen() {&#10;    EnsureNotificationPermission()&#10;    val context = LocalContext.current&#10;&#10;    var todos by remember { mutableStateOf(listOf&lt;TodoItem&gt;()) }&#10;    var activityLog by remember { mutableStateOf(listOf&lt;ActivityLogEntry&gt;()) }&#10;    var showAddDialog by remember { mutableStateOf(false) }&#10;    var showEditDialog by remember { mutableStateOf(false) }&#10;    var showFilterDialog by remember { mutableStateOf(false) }&#10;    var showActivityDialog by remember { mutableStateOf(false) }&#10;    var showTaskDetailsDialog by remember { mutableStateOf(false) }&#10;    var editingTodo by remember { mutableStateOf&lt;TodoItem?&gt;(null) }&#10;    var selectedTodoForDetails by remember { mutableStateOf&lt;TodoItem?&gt;(null) }&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedCategory by remember { mutableStateOf(&quot;All&quot;) }&#10;    var selectedPriority by remember { mutableStateOf(&quot;All&quot;) }&#10;    var showCompleted by remember { mutableStateOf(true) }&#10;    var viewMode by remember { mutableStateOf(ViewMode.LIST) }&#10;    val systemDark = isSystemInDarkTheme()&#10;    var isDarkTheme by remember { mutableStateOf(systemDark) }&#10;&#10;    // Filter logic&#10;    val filteredTodos = remember(todos, searchQuery, selectedCategory, selectedPriority, showCompleted) {&#10;        todos.filter { todo -&gt;&#10;            val matchesSearch = searchQuery.isBlank() ||&#10;                todo.title.contains(searchQuery, ignoreCase = true) ||&#10;                todo.notes.contains(searchQuery, ignoreCase = true)&#10;            val matchesCategory = selectedCategory == &quot;All&quot; || todo.category == selectedCategory&#10;            val matchesPriority = selectedPriority == &quot;All&quot; || todo.priority == selectedPriority&#10;            val matchesCompletion = showCompleted || !todo.isDone&#10;&#10;            matchesSearch &amp;&amp; matchesCategory &amp;&amp; matchesPriority &amp;&amp; matchesCompletion&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = Modifier.fillMaxSize(),&#10;        floatingActionButton = {&#10;            FloatingActionButton(&#10;                onClick = { showAddDialog = true },&#10;                containerColor = Color(0xFF4A90E2)&#10;            ) {&#10;                Icon(Icons.Default.Add, contentDescription = &quot;Add&quot;, tint = Color.White)&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            // Top App Bar with theme toggle and view mode&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;My Tasks&quot;,&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Row {&#10;                    // Theme Toggle&#10;                    IconButton(onClick = { isDarkTheme = !isDarkTheme }) {&#10;                        Icon(&#10;                            if (isDarkTheme) Icons.Filled.LightMode else Icons.Filled.DarkMode,&#10;                            contentDescription = &quot;Toggle theme&quot;&#10;                        )&#10;                    }&#10;                    // Activity Log Button&#10;                    IconButton(onClick = { showActivityDialog = true }) {&#10;                        Icon(Icons.Filled.History, contentDescription = &quot;Activity Log&quot;)&#10;                    }&#10;                    // View Mode Toggle&#10;                    IconButton(&#10;                        onClick = {&#10;                            viewMode = if (viewMode == ViewMode.LIST) ViewMode.CALENDAR else ViewMode.LIST&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            if (viewMode == ViewMode.LIST) Icons.Filled.CalendarToday else Icons.AutoMirrored.Filled.List,&#10;                            contentDescription = &quot;Toggle view mode&quot;&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Progress Overview&#10;            if (todos.isNotEmpty()) {&#10;                ProgressOverview(todos = todos)&#10;            }&#10;&#10;            // Search and Filter Row&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = searchQuery,&#10;                    onValueChange = { searchQuery = it },&#10;                    placeholder = { Text(&quot;Search tasks...&quot;) },&#10;                    leadingIcon = { Icon(Icons.Filled.Search, contentDescription = &quot;Search&quot;) },&#10;                    modifier = Modifier.weight(1f),&#10;                    trailingIcon = {&#10;                        if (searchQuery.isNotBlank()) {&#10;                            IconButton(&#10;                                onClick = { searchQuery = &quot;&quot; }&#10;                            ) {&#10;                                Icon(Icons.Filled.Clear, contentDescription = &quot;Clear search&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                IconButton(&#10;                    onClick = { showFilterDialog = true },&#10;                    modifier = Modifier.size(48.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Filled.FilterList,&#10;                        contentDescription = &quot;Filter&quot;,&#10;                        tint = if (selectedCategory != &quot;All&quot; || selectedPriority != &quot;All&quot; || !showCompleted)&#10;                            Color(0xFF4A90E2) else Color.Gray&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Active filters display&#10;            if (selectedCategory != &quot;All&quot; || selectedPriority != &quot;All&quot; || !showCompleted) {&#10;                LazyRow(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    if (selectedCategory != &quot;All&quot;) {&#10;                        item {&#10;                            FilterChip(&#10;                                onClick = { selectedCategory = &quot;All&quot; },&#10;                                label = { Text(&quot;Category: $selectedCategory&quot;) },&#10;                                selected = true,&#10;                                trailingIcon = { Icon(Icons.Filled.Clear, contentDescription = &quot;Remove filter&quot;) }&#10;                            )&#10;                        }&#10;                    }&#10;                    if (selectedPriority != &quot;All&quot;) {&#10;                        item {&#10;                            FilterChip(&#10;                                onClick = { selectedPriority = &quot;All&quot; },&#10;                                label = { Text(&quot;Priority: $selectedPriority&quot;) },&#10;                                selected = true,&#10;                                trailingIcon = { Icon(Icons.Filled.Clear, contentDescription = &quot;Remove filter&quot;) }&#10;                            )&#10;                        }&#10;                    }&#10;                    if (!showCompleted) {&#10;                        item {&#10;                            FilterChip(&#10;                                onClick = { showCompleted = true },&#10;                                label = { Text(&quot;Hide Completed&quot;) },&#10;                                selected = true,&#10;                                trailingIcon = { Icon(Icons.Filled.Clear, contentDescription = &quot;Remove filter&quot;) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;&#10;            // Content based on view mode&#10;            when (viewMode) {&#10;                ViewMode.LIST -&gt; {&#10;                    // Todo List&#10;                    if (filteredTodos.isEmpty()) {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = if (todos.isEmpty()) &quot;No tasks yet. Tap the + button to add your first task!&quot;&#10;                                       else &quot;No tasks match your search or filters.&quot;,&#10;                                color = Color(0xFFBDBDBD),&#10;                                fontSize = 18.sp,&#10;                                lineHeight = 24.sp&#10;                            )&#10;                        }&#10;                    } else {&#10;                        LazyColumn(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentPadding = PaddingValues(vertical = 16.dp)&#10;                        ) {&#10;                            itemsIndexed(filteredTodos) { index, todo -&gt;&#10;                                EnhancedTodoDetailScreen(&#10;                                    todo = todo,&#10;                                    onEdit = {&#10;                                        editingTodo = todo&#10;                                        showEditDialog = true&#10;                                    },&#10;                                    onToggleComplete = {&#10;                                        val updatedTodos = handleTaskCompletion(todos, todo, context)&#10;                                        todos = updatedTodos&#10;                                        // Log activity&#10;                                        val action = if (todo.isDone) &quot;uncompleted&quot; else &quot;completed&quot;&#10;                                        activityLog = activityLog + ActivityLogEntry(&#10;                                            taskId = todo.id,&#10;                                            taskTitle = todo.title,&#10;                                            action = action,&#10;                                            details = &quot;Task $action by user&quot;&#10;                                        )&#10;                                    },&#10;                                    onViewDetails = {&#10;                                        selectedTodoForDetails = todo&#10;                                        showTaskDetailsDialog = true&#10;                                    }&#10;                                )&#10;                                Spacer(modifier = Modifier.height(16.dp))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                ViewMode.CALENDAR -&gt; {&#10;                    CalendarView(todos = filteredTodos)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Dialogs&#10;        if (showAddDialog) {&#10;            AddTodoDialog(&#10;                onAdd = { title: String, notes: String, dueDate: String, category: String, priority: String, isRecurring: Boolean, recurrenceType: RecurrenceType, customInterval: Int -&gt;&#10;                    val newItem = TodoItem(title = title, notes = notes, dueDate = dueDate, category = category, priority = priority, isRecurring = isRecurring, recurrenceType = recurrenceType, customInterval = customInterval)&#10;                    todos = todos + newItem&#10;                    // Log activity&#10;                    activityLog = activityLog + ActivityLogEntry(&#10;                        taskId = newItem.id,&#10;                        taskTitle = newItem.title,&#10;                        action = &quot;created&quot;,&#10;                        details = &quot;New task created with category: $category, priority: $priority&quot;&#10;                    )&#10;                    if (!newItem.isDone &amp;&amp; newItem.dueDate.isNotBlank()) {&#10;                        ReminderScheduler.schedule(context, newItem.id, newItem.title, newItem.notes, newItem.dueDate)&#10;                    }&#10;                    showAddDialog = false&#10;                },&#10;                onDismiss = { showAddDialog = false }&#10;            )&#10;        }&#10;&#10;        if (showEditDialog &amp;&amp; editingTodo != null) {&#10;            val todo = editingTodo!!&#10;            EditTodoDialog(&#10;                initialTitle = todo.title,&#10;                initialNotes = todo.notes,&#10;                initialDueDate = todo.dueDate,&#10;                initialCategory = todo.category,&#10;                initialPriority = todo.priority,&#10;                onEdit = { newTitle: String, newNotes: String, newDueDate: String, newCategory: String, newPriority: String -&gt;&#10;                    todos = todos.map {&#10;                        if (it.id == todo.id) {&#10;                            val updated = it.copy(title = newTitle, notes = newNotes, dueDate = newDueDate, category = newCategory, priority = newPriority)&#10;                            ReminderScheduler.cancel(context, todo.id)&#10;                            if (!updated.isDone &amp;&amp; updated.dueDate.isNotBlank()) {&#10;                                ReminderScheduler.schedule(context, updated.id, updated.title, updated.notes, updated.dueDate)&#10;                            }&#10;                            // Log activity&#10;                            activityLog = activityLog + ActivityLogEntry(&#10;                                taskId = todo.id,&#10;                                taskTitle = newTitle,&#10;                                action = &quot;updated&quot;,&#10;                                details = &quot;Task details modified&quot;&#10;                            )&#10;                            updated&#10;                        } else it&#10;                    }&#10;                    showEditDialog = false&#10;                    editingTodo = null&#10;                },&#10;                onDelete = {&#10;                    ReminderScheduler.cancel(context, todo.id)&#10;                    todos = todos.filter { it.id != todo.id }&#10;                    // Log activity&#10;                    activityLog = activityLog + ActivityLogEntry(&#10;                        taskId = todo.id,&#10;                        taskTitle = todo.title,&#10;                        action = &quot;deleted&quot;,&#10;                        details = &quot;Task permanently deleted&quot;&#10;                    )&#10;                    showEditDialog = false&#10;                    editingTodo = null&#10;                },&#10;                onDismiss = {&#10;                    showEditDialog = false&#10;                    editingTodo = null&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showFilterDialog) {&#10;            FilterDialog(&#10;                currentCategory = selectedCategory,&#10;                currentPriority = selectedPriority,&#10;                showCompleted = showCompleted,&#10;                onCategoryChange = { selectedCategory = it },&#10;                onPriorityChange = { selectedPriority = it },&#10;                onShowCompletedChange = { showCompleted = it },&#10;                onDismiss = { showFilterDialog = false }&#10;            )&#10;        }&#10;&#10;        if (showActivityDialog) {&#10;            ActivityLogDialog(&#10;                activityLog = activityLog,&#10;                onDismiss = { showActivityDialog = false }&#10;            )&#10;        }&#10;&#10;        if (showTaskDetailsDialog &amp;&amp; selectedTodoForDetails != null) {&#10;            TaskDetailsDialog(&#10;                todo = selectedTodoForDetails!!,&#10;                onDismiss = {&#10;                    showTaskDetailsDialog = false&#10;                    selectedTodoForDetails = null&#10;                },&#10;                onAddComment = { comment -&gt;&#10;                    todos = todos.map {&#10;                        if (it.id == selectedTodoForDetails!!.id) {&#10;                            val newComment = TaskComment(text = comment)&#10;                            val updated = it.copy(comments = it.comments + newComment)&#10;                            // Log activity&#10;                            activityLog = activityLog + ActivityLogEntry(&#10;                                taskId = it.id,&#10;                                taskTitle = it.title,&#10;                                action = &quot;comment_added&quot;,&#10;                                details = &quot;Comment added: ${comment.take(50)}${if (comment.length &gt; 50) &quot;...&quot; else &quot;&quot;}&quot;&#10;                            )&#10;                            updated&#10;                        } else it&#10;                    }&#10;                    selectedTodoForDetails = todos.find { it.id == selectedTodoForDetails!!.id }&#10;                },&#10;                onUpdateProgress = { percentage -&gt;&#10;                    todos = todos.map {&#10;                        if (it.id == selectedTodoForDetails!!.id) {&#10;                            val updated = it.copy(completionPercentage = percentage)&#10;                            // Log activity&#10;                            activityLog = activityLog + ActivityLogEntry(&#10;                                taskId = it.id,&#10;                                taskTitle = it.title,&#10;                                action = &quot;progress_updated&quot;,&#10;                                details = &quot;Progress updated to $percentage%&quot;&#10;                            )&#10;                            updated&#10;                        } else it&#10;                    }&#10;                    selectedTodoForDetails = todos.find { it.id == selectedTodoForDetails!!.id }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Suppress(&quot;unused&quot;)&#10;@Composable&#10;fun TodoDetailScreen(&#10;    todo: TodoItem,&#10;    onEdit: () -&gt; Unit,&#10;    onToggleComplete: () -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(top = 32.dp, start = 24.dp, end = 24.dp)&#10;    ) {&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Checkbox(&#10;                checked = todo.isDone,&#10;                onCheckedChange = { onToggleComplete() },&#10;                modifier = Modifier.size(32.dp),&#10;                colors = CheckboxDefaults.colors(&#10;                    checkedColor = Color(0xFF4A90E2),&#10;                    uncheckedColor = Color(0xFF4A90E2),&#10;                    checkmarkColor = Color.White&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(&#10;                text = todo.title,&#10;                fontSize = 32.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color(0xFF222222)&#10;            )&#10;            // Recurring indicator&#10;            if (todo.isRecurring &amp;&amp; todo.recurrenceType != RecurrenceType.NONE) {&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = &quot;&quot;,&#10;                    fontSize = 20.sp,&#10;                    color = Color(0xFF4A90E2)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Column(modifier = Modifier.align(Alignment.CenterVertically)) {&#10;                Text(&#10;                    text = todo.category,&#10;                    color = Color(0xFF4A90E2),&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 2.dp)&#10;                )&#10;                Text(&#10;                    text = todo.priority,&#10;                    color = when (todo.priority) {&#10;                        &quot;High&quot; -&gt; Color.Red&#10;                        &quot;Medium&quot; -&gt; Color(0xFFFFA500)&#10;                        else -&gt; Color(0xFF4CAF50)&#10;                    },&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Medium,&#10;                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 2.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            IconButton(onClick = onEdit) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.MoreVert,&#10;                    contentDescription = &quot;More&quot;,&#10;                    tint = Color(0xFFBDBDBD)&#10;                )&#10;            }&#10;        }&#10;        if (todo.dueDate.isNotBlank()) {&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = &quot;Due: ${todo.dueDate}&quot;,&#10;                color = Color(0xFFBDBDBD),&#10;                fontSize = 16.sp,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;        }&#10;        if (todo.isRecurring &amp;&amp; todo.recurrenceType != RecurrenceType.NONE) {&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = &quot;Repeats: ${getRecurrenceDisplay(todo.recurrenceType, todo.customInterval)}&quot;,&#10;                color = Color(0xFF4A90E2),&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Text(&#10;            text = &quot;Notes&quot;,&#10;            color = Color(0xFFBDBDBD),&#10;            fontSize = 18.sp,&#10;            modifier = Modifier.padding(start = 8.dp, top = 8.dp)&#10;        )&#10;        if (todo.notes.isNotBlank()) {&#10;            Text(&#10;                text = todo.notes,&#10;                color = Color(0xFF757575),&#10;                fontSize = 18.sp,&#10;                modifier = Modifier.padding(start = 8.dp, top = 4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun getRecurrenceDisplay(recurrenceType: RecurrenceType, customInterval: Int): String {&#10;    return when (recurrenceType) {&#10;        RecurrenceType.DAILY -&gt; &quot;Daily&quot;&#10;        RecurrenceType.WEEKLY -&gt; &quot;Weekly&quot;&#10;        RecurrenceType.MONTHLY -&gt; &quot;Monthly&quot;&#10;        RecurrenceType.CUSTOM_DAYS -&gt; &quot;Every $customInterval days&quot;&#10;        RecurrenceType.NONE -&gt; &quot;&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;fun AddTodoDialog(&#10;    onAdd: (title: String, notes: String, dueDate: String, category: String, priority: String, isRecurring: Boolean, recurrenceType: RecurrenceType, customInterval: Int) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var notes by remember { mutableStateOf(&quot;&quot;) }&#10;    var dueDate by remember { mutableStateOf(&quot;&quot;) }&#10;    var category by remember { mutableStateOf(&quot;Personal&quot;) }&#10;    var priority by remember { mutableStateOf(&quot;Medium&quot;) }&#10;    var isRecurring by remember { mutableStateOf(false) }&#10;    var recurrenceType by remember { mutableStateOf(RecurrenceType.DAILY) }&#10;    var customInterval by remember { mutableIntStateOf(1) }&#10;    var showDatePicker by remember { mutableStateOf(false) }&#10;&#10;    val dateFormat = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;    val dueDateDisplay = dueDate&#10;    val today = remember { Calendar.getInstance().apply { set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0) }.timeInMillis }&#10;    val datePickerState = rememberDatePickerState(&#10;        initialDisplayedMonthMillis = today&#10;    )&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;New To-Do&quot;) },&#10;        text = {&#10;            LazyColumn {&#10;                item {&#10;                    OutlinedTextField(&#10;                        value = title,&#10;                        onValueChange = { title = it },&#10;                        label = { Text(&quot;Title&quot;) },&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;                item {&#10;                    OutlinedTextField(&#10;                        value = notes,&#10;                        onValueChange = { notes = it },&#10;                        label = { Text(&quot;Notes&quot;) },&#10;                        modifier = Modifier.padding(top = 8.dp).fillMaxWidth()&#10;                    )&#10;                }&#10;                item {&#10;                    OutlinedTextField(&#10;                        value = dueDateDisplay,&#10;                        onValueChange = {},&#10;                        label = { Text(&quot;Due Date&quot;) },&#10;                        modifier = Modifier&#10;                            .padding(top = 8.dp)&#10;                            .fillMaxWidth()&#10;                            .clickable { showDatePicker = true },&#10;                        readOnly = true,&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { showDatePicker = true }) {&#10;                                Icon(Icons.Filled.Event, contentDescription = &quot;Pick date&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Recurring Task Section&#10;                item {&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(top = 16.dp)&#10;                            .clickable { isRecurring = !isRecurring }&#10;                    ) {&#10;                        Checkbox(&#10;                            checked = isRecurring,&#10;                            onCheckedChange = { isRecurring = it }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&quot;Recurring Task&quot;, fontWeight = FontWeight.Medium)&#10;                    }&#10;                }&#10;&#10;                if (isRecurring) {&#10;                    item {&#10;                        // Recurrence Type Dropdown&#10;                        val recurrenceTypes = listOf(&quot;Daily&quot;, &quot;Weekly&quot;, &quot;Monthly&quot;, &quot;Custom Days&quot;)&#10;                        var expandedRecurrence by remember { mutableStateOf(false) }&#10;                        Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                            OutlinedTextField(&#10;                                value = when (recurrenceType) {&#10;                                    RecurrenceType.DAILY -&gt; &quot;Daily&quot;&#10;                                    RecurrenceType.WEEKLY -&gt; &quot;Weekly&quot;&#10;                                    RecurrenceType.MONTHLY -&gt; &quot;Monthly&quot;&#10;                                    RecurrenceType.CUSTOM_DAYS -&gt; &quot;Custom Days&quot;&#10;                                    else -&gt; &quot;Daily&quot;&#10;                                },&#10;                                onValueChange = {},&#10;                                label = { Text(&quot;Repeat&quot;) },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable { expandedRecurrence = true },&#10;                                readOnly = true,&#10;                                trailingIcon = {&#10;                                    IconButton(onClick = { expandedRecurrence = true }) {&#10;                                        Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select recurrence&quot;)&#10;                                    }&#10;                                }&#10;                            )&#10;                            DropdownMenu(&#10;                                expanded = expandedRecurrence,&#10;                                onDismissRequest = { expandedRecurrence = false }&#10;                            ) {&#10;                                recurrenceTypes.forEachIndexed { index, type -&gt;&#10;                                    DropdownMenuItem(&#10;                                        text = { Text(type) },&#10;                                        onClick = {&#10;                                            recurrenceType = when (index) {&#10;                                                0 -&gt; RecurrenceType.DAILY&#10;                                                1 -&gt; RecurrenceType.WEEKLY&#10;                                                2 -&gt; RecurrenceType.MONTHLY&#10;                                                3 -&gt; RecurrenceType.CUSTOM_DAYS&#10;                                                else -&gt; RecurrenceType.DAILY&#10;                                            }&#10;                                            expandedRecurrence = false&#10;                                        }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    if (recurrenceType == RecurrenceType.CUSTOM_DAYS) {&#10;                        item {&#10;                            OutlinedTextField(&#10;                                value = customInterval.toString(),&#10;                                onValueChange = {&#10;                                    val newValue = it.toIntOrNull()&#10;                                    if (newValue != null &amp;&amp; newValue &gt; 0) {&#10;                                        customInterval = newValue&#10;                                    }&#10;                                },&#10;                                label = { Text(&quot;Every X days&quot;) },&#10;                                modifier = Modifier.padding(top = 8.dp).fillMaxWidth(),&#10;                                singleLine = true&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Category Dropdown&#10;                item {&#10;                    val categories = listOf(&quot;Personal&quot;, &quot;Work&quot;, &quot;School&quot;)&#10;                    var expanded by remember { mutableStateOf(false) }&#10;                    Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                        OutlinedTextField(&#10;                            value = category,&#10;                            onValueChange = {},&#10;                            label = { Text(&quot;Category&quot;) },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { expanded = true },&#10;                            readOnly = true,&#10;                            trailingIcon = {&#10;                                IconButton(onClick = { expanded = true }) {&#10;                                    Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select category&quot;)&#10;                                }&#10;                            }&#10;                        )&#10;                        DropdownMenu(&#10;                            expanded = expanded,&#10;                            onDismissRequest = { expanded = false }&#10;                        ) {&#10;                            categories.forEach { cat -&gt;&#10;                                DropdownMenuItem(&#10;                                    text = { Text(cat) },&#10;                                    onClick = {&#10;                                        category = cat&#10;                                        expanded = false&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Priority Dropdown&#10;                item {&#10;                    val priorities = listOf(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)&#10;                    var expandedPriority by remember { mutableStateOf(false) }&#10;                    Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                        OutlinedTextField(&#10;                            value = priority,&#10;                            onValueChange = {},&#10;                            label = { Text(&quot;Priority&quot;) },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { expandedPriority = true },&#10;                            readOnly = true,&#10;                            trailingIcon = {&#10;                                IconButton(onClick = { expandedPriority = true }) {&#10;                                    Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select priority&quot;)&#10;                                }&#10;                            }&#10;                        )&#10;                        DropdownMenu(&#10;                            expanded = expandedPriority,&#10;                            onDismissRequest = { expandedPriority = false }&#10;                        ) {&#10;                            priorities.forEach { p -&gt;&#10;                                DropdownMenuItem(&#10;                                    text = { Text(p) },&#10;                                    onClick = {&#10;                                        priority = p&#10;                                        expandedPriority = false&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(&#10;                onClick = {&#10;                    if (title.isNotBlank()) {&#10;                        onAdd(&#10;                            title,&#10;                            notes,&#10;                            dueDate,&#10;                            category,&#10;                            priority,&#10;                            isRecurring,&#10;                            if (isRecurring) recurrenceType else RecurrenceType.NONE,&#10;                            customInterval&#10;                        )&#10;                    }&#10;                }&#10;            ) { Text(&quot;Add&quot;) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cancel&quot;) }&#10;        }&#10;    )&#10;&#10;    var showWarning by remember { mutableStateOf(false) }&#10;    if (showDatePicker) {&#10;        DatePickerDialog(&#10;            onDismissRequest = { showDatePicker = false },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    val millis = datePickerState.selectedDateMillis&#10;                    if (millis != null &amp;&amp; millis &gt;= today) {&#10;                        dueDate = dateFormat.format(Date(millis))&#10;                        showDatePicker = false&#10;                    } else {&#10;                        showWarning = true&#10;                    }&#10;                }) { Text(&quot;OK&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showDatePicker = false }) { Text(&quot;Cancel&quot;) }&#10;            }&#10;        ) {&#10;            CustomDatePicker(state = datePickerState)&#10;        }&#10;    }&#10;    if (showWarning) {&#10;        AlertDialog(&#10;            onDismissRequest = { showWarning = false },&#10;            title = { Text(&quot;Invalid Date&quot;) },&#10;            text = { Text(&quot;You cannot select a past date. Please choose today or a future date.&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = { showWarning = false }) { Text(&quot;OK&quot;) }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;fun EditTodoDialog(&#10;    initialTitle: String,&#10;    initialNotes: String,&#10;    initialDueDate: String,&#10;    initialCategory: String,&#10;    initialPriority: String,&#10;    onEdit: (newTitle: String, newNotes: String, newDueDate: String, newCategory: String, newPriority: String) -&gt; Unit,&#10;    onDelete: () -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    var title by remember { mutableStateOf(initialTitle) }&#10;    var notes by remember { mutableStateOf(initialNotes) }&#10;    var dueDate by remember { mutableStateOf(initialDueDate) }&#10;    var category by remember { mutableStateOf(initialCategory) }&#10;    var priority by remember { mutableStateOf(initialPriority) }&#10;    var showDatePicker by remember { mutableStateOf(false) }&#10;&#10;    val dateFormat = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;    val dueDateDisplay = dueDate&#10;    val today = remember { Calendar.getInstance().apply { set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0) }.timeInMillis }&#10;    val datePickerState = rememberDatePickerState(&#10;        initialSelectedDateMillis = try { dateFormat.parse(initialDueDate)?.time } catch (_: Exception) { null },&#10;        initialDisplayedMonthMillis = today&#10;    )&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Edit To-Do&quot;) },&#10;        text = {&#10;            Column {&#10;                OutlinedTextField(&#10;                    value = title,&#10;                    onValueChange = { title = it },&#10;                    label = { Text(&quot;Title&quot;) },&#10;                    singleLine = true&#10;                )&#10;                OutlinedTextField(&#10;                    value = notes,&#10;                    onValueChange = { notes = it },&#10;                    label = { Text(&quot;Notes&quot;) },&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;                OutlinedTextField(&#10;                    value = dueDateDisplay,&#10;                    onValueChange = {},&#10;                    label = { Text(&quot;Due Date&quot;) },&#10;                    modifier = Modifier&#10;                        .padding(top = 8.dp)&#10;                        .clickable { showDatePicker = true },&#10;                    readOnly = true,&#10;                    trailingIcon = {&#10;                        IconButton(onClick = { showDatePicker = true }) {&#10;                            Icon(Icons.Filled.Event, contentDescription = &quot;Pick date&quot;)&#10;                        }&#10;                    }&#10;                )&#10;                var showWarning by remember { mutableStateOf(false) }&#10;                if (showDatePicker) {&#10;                    DatePickerDialog(&#10;                        onDismissRequest = { showDatePicker = false },&#10;                        confirmButton = {&#10;                            TextButton(onClick = {&#10;                                val millis = datePickerState.selectedDateMillis&#10;                                if (millis != null &amp;&amp; millis &gt;= today) {&#10;                                    dueDate = dateFormat.format(Date(millis))&#10;                                    showDatePicker = false&#10;                                } else {&#10;                                    showWarning = true&#10;                                }&#10;                            }) { Text(&quot;OK&quot;) }&#10;                        },&#10;                        dismissButton = {&#10;                            TextButton(onClick = { showDatePicker = false }) { Text(&quot;Cancel&quot;) }&#10;                        }&#10;                    ) {&#10;                        CustomDatePicker(state = datePickerState)&#10;                    }&#10;                }&#10;                if (showWarning) {&#10;                    AlertDialog(&#10;                        onDismissRequest = { showWarning = false },&#10;                        title = { Text(&quot;Invalid Date&quot;) },&#10;                        text = { Text(&quot;You cannot select a past date. Please choose today or a future date.&quot;) },&#10;                        confirmButton = {&#10;                            TextButton(onClick = { showWarning = false }) { Text(&quot;OK&quot;) }&#10;                        }&#10;                    )&#10;                }&#10;                // Category Dropdown&#10;                val categories = listOf(&quot;Personal&quot;, &quot;Work&quot;, &quot;School&quot;)&#10;                var expanded by remember { mutableStateOf(false) }&#10;                Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                    OutlinedTextField(&#10;                        value = category,&#10;                        onValueChange = {},&#10;                        label = { Text(&quot;Category&quot;) },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { expanded = true },&#10;                        readOnly = true,&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { expanded = true }) {&#10;                                Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select category&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                    DropdownMenu(&#10;                        expanded = expanded,&#10;                        onDismissRequest = { expanded = false }&#10;                    ) {&#10;                        categories.forEach { cat -&gt;&#10;                            DropdownMenuItem(&#10;                                text = { Text(cat) },&#10;                                onClick = {&#10;                                    category = cat&#10;                                    expanded = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                // Priority Dropdown&#10;                val priorities = listOf(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)&#10;                var expandedPriority by remember { mutableStateOf(false) }&#10;                Box(modifier = Modifier.padding(top = 8.dp)) {&#10;                    OutlinedTextField(&#10;                        value = priority,&#10;                        onValueChange = {},&#10;                        label = { Text(&quot;Priority&quot;) },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { expandedPriority = true },&#10;                        readOnly = true,&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { expandedPriority = true }) {&#10;                                Icon(Icons.Filled.MoreVert, contentDescription = &quot;Select priority&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                    DropdownMenu(&#10;                        expanded = expandedPriority,&#10;                        onDismissRequest = { expandedPriority = false }&#10;                    ) {&#10;                        priorities.forEach { p -&gt;&#10;                            DropdownMenuItem(&#10;                                text = { Text(p) },&#10;                                onClick = {&#10;                                    priority = p&#10;                                    expandedPriority = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Row {&#10;                TextButton(&#10;                    onClick = {&#10;                        if (title.isNotBlank()) onEdit(title, notes, dueDate, category, priority)&#10;                    }&#10;                ) { Text(&quot;Save&quot;) }&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                TextButton(&#10;                    onClick = onDelete&#10;                ) { Text(&quot;Delete&quot;, color = Color.Red) }&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cancel&quot;) }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun FilterDialog(&#10;    currentCategory: String,&#10;    currentPriority: String,&#10;    showCompleted: Boolean,&#10;    onCategoryChange: (String) -&gt; Unit,&#10;    onPriorityChange: (String) -&gt; Unit,&#10;    onShowCompletedChange: (Boolean) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Filter Tasks&quot;) },&#10;        text = {&#10;            Column {&#10;                // Category Filter&#10;                Text(&quot;Category&quot;, fontWeight = FontWeight.Medium)&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                val categories = listOf(&quot;All&quot;, &quot;Personal&quot;, &quot;Work&quot;, &quot;School&quot;)&#10;                categories.forEach { category -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onCategoryChange(category) }&#10;                            .padding(vertical = 4.dp)&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = currentCategory == category,&#10;                            onClick = { onCategoryChange(category) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(category)&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Priority Filter&#10;                Text(&quot;Priority&quot;, fontWeight = FontWeight.Medium)&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                val priorities = listOf(&quot;All&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)&#10;                priorities.forEach { priority -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onPriorityChange(priority) }&#10;                            .padding(vertical = 4.dp)&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = currentPriority == priority,&#10;                            onClick = { onPriorityChange(priority) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(priority)&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Show Completed Toggle&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { onShowCompletedChange(!showCompleted) }&#10;                        .padding(vertical = 4.dp)&#10;                ) {&#10;                    Checkbox(&#10;                        checked = showCompleted,&#10;                        onCheckedChange = onShowCompletedChange&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&quot;Show completed tasks&quot;)&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Done&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = {&#10;                onCategoryChange(&quot;All&quot;)&#10;                onPriorityChange(&quot;All&quot;)&#10;                onShowCompletedChange(true)&#10;            }) {&#10;                Text(&quot;Clear All&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;fun CustomDatePicker(state: DatePickerState) {&#10;    Box {&#10;        DatePicker(state = state)&#10;    }&#10;}&#10;&#10;&#10;// Utility function to handle task completion and recurring task logic&#10;fun handleTaskCompletion(todos: List&lt;TodoItem&gt;, completedTodo: TodoItem, context: Context): List&lt;TodoItem&gt; {&#10;    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    val today = dateFormat.format(Date())&#10;&#10;    return todos.map { todo -&gt;&#10;        if (todo.id == completedTodo.id) {&#10;            val toggled = todo.copy(&#10;                isDone = !todo.isDone,&#10;                lastCompleted = if (!todo.isDone) today else &quot;&quot;&#10;            )&#10;&#10;            // Handle reminders&#10;            if (toggled.isDone) {&#10;                ReminderScheduler.cancel(context, toggled.id)&#10;            } else if (toggled.dueDate.isNotBlank()) {&#10;                ReminderScheduler.schedule(context, toggled.id, toggled.title, toggled.notes, toggled.dueDate)&#10;            }&#10;&#10;            toggled&#10;        } else {&#10;            todo&#10;        }&#10;    }.let { updatedTodos -&gt;&#10;        // If completing a recurring task, create the next instance&#10;        val completedTask = updatedTodos.find { it.id == completedTodo.id }&#10;        if (completedTask?.isDone == true &amp;&amp; completedTask.isRecurring &amp;&amp; completedTask.recurrenceType != RecurrenceType.NONE) {&#10;            val nextDueDate = calculateNextDueDate(completedTask.dueDate, completedTask.recurrenceType, completedTask.customInterval)&#10;            if (nextDueDate.isNotBlank()) {&#10;                val nextTask = completedTask.copy(&#10;                    id = UUID.randomUUID().toString(),&#10;                    isDone = false,&#10;                    dueDate = nextDueDate,&#10;                    lastCompleted = &quot;&quot;,&#10;                    originalId = completedTask.originalId.ifBlank { completedTask.id }&#10;                )&#10;&#10;                // Schedule reminder for the new instance&#10;                ReminderScheduler.schedule(context, nextTask.id, nextTask.title, nextTask.notes, nextTask.dueDate)&#10;&#10;                updatedTodos + nextTask&#10;            } else {&#10;                updatedTodos&#10;            }&#10;        } else {&#10;            updatedTodos&#10;        }&#10;    }&#10;}&#10;&#10;// Calculate the next due date based on recurrence type&#10;fun calculateNextDueDate(currentDueDate: String, recurrenceType: RecurrenceType, customInterval: Int): String {&#10;    if (currentDueDate.isBlank()) return &quot;&quot;&#10;&#10;    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    return try {&#10;        val currentDate = dateFormat.parse(currentDueDate) ?: return &quot;&quot;&#10;        val calendar = Calendar.getInstance().apply { time = currentDate }&#10;&#10;        when (recurrenceType) {&#10;            RecurrenceType.DAILY -&gt; calendar.add(Calendar.DAY_OF_MONTH, 1)&#10;            RecurrenceType.WEEKLY -&gt; calendar.add(Calendar.WEEK_OF_YEAR, 1)&#10;            RecurrenceType.MONTHLY -&gt; calendar.add(Calendar.MONTH, 1)&#10;            RecurrenceType.CUSTOM_DAYS -&gt; calendar.add(Calendar.DAY_OF_MONTH, customInterval)&#10;            RecurrenceType.NONE -&gt; return &quot;&quot;&#10;        }&#10;&#10;        dateFormat.format(calendar.time)&#10;    } catch (_: Exception) {&#10;        &quot;&quot;&#10;    }&#10;}&#10;&#10;// Progress Overview component&#10;@Composable&#10;fun ProgressOverview(todos: List&lt;TodoItem&gt;) {&#10;    val totalTasks = todos.size&#10;    val completedTasks = todos.count { it.isDone }&#10;    val completionPercentage = if (totalTasks &gt; 0) (completedTasks * 100) / totalTasks else 0&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFFF5F5F5))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Progress Overview&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;                Text(&#10;                    text = &quot;$completedTasks/$totalTasks completed&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF757575)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            LinearProgressIndicator(&#10;                progress = { completionPercentage / 100f },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(8.dp)&#10;                    .clip(RoundedCornerShape(4.dp)),&#10;                color = Color(0xFF4A90E2),&#10;                trackColor = Color(0xFFE0E0E0),&#10;                strokeCap = StrokeCap.Round&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Text(&#10;                text = &quot;$completionPercentage% Complete&quot;,&#10;                fontSize = 14.sp,&#10;                color = Color(0xFF4A90E2),&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainScreenPreview() {&#10;    ToDoTheme {&#10;        MainScreen()&#10;    }&#10;}&#10;&#10;// Enhanced Todo Detail Screen with progress tracking and additional features&#10;@Composable&#10;fun EnhancedTodoDetailScreen(&#10;    todo: TodoItem,&#10;    onEdit: () -&gt; Unit,&#10;    onToggleComplete: () -&gt; Unit,&#10;    onViewDetails: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp)&#10;            .clickable { onViewDetails() },&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (todo.isDone) Color(0xFFF5F5F5) else Color.White&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Checkbox(&#10;                    checked = todo.isDone,&#10;                    onCheckedChange = { onToggleComplete() },&#10;                    colors = CheckboxDefaults.colors(&#10;                        checkedColor = Color(0xFF4A90E2),&#10;                        uncheckedColor = Color(0xFF4A90E2),&#10;                        checkmarkColor = Color.White&#10;                    )&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Text(&#10;                            text = todo.title,&#10;                            fontSize = 18.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = if (todo.isDone) Color(0xFF757575) else Color(0xFF222222)&#10;                        )&#10;&#10;                        if (todo.isRecurring &amp;&amp; todo.recurrenceType != RecurrenceType.NONE) {&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = &quot;&quot;,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF4A90E2)&#10;                            )&#10;                        }&#10;&#10;                        if (todo.comments.isNotEmpty()) {&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Icon(&#10;                                Icons.AutoMirrored.Filled.Comment,&#10;                                contentDescription = &quot;Has comments&quot;,&#10;                                tint = Color(0xFF4A90E2),&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    if (todo.notes.isNotBlank()) {&#10;                        Text(&#10;                            text = todo.notes,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF757575),&#10;                            maxLines = 2,&#10;                            modifier = Modifier.padding(top = 4.dp)&#10;                        )&#10;                    }&#10;&#10;                    // Progress bar for individual task progress&#10;                    if (todo.completionPercentage &gt; 0 &amp;&amp; !todo.isDone) {&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            LinearProgressIndicator(&#10;                                progress = { todo.completionPercentage / 100f },&#10;                                modifier = Modifier&#10;                                    .weight(1f)&#10;                                    .height(6.dp)&#10;                                    .clip(RoundedCornerShape(3.dp)),&#10;                                color = Color(0xFF4A90E2),&#10;                                trackColor = Color(0xFFE0E0E0)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = &quot;${todo.completionPercentage}%&quot;,&#10;                                fontSize = 12.sp,&#10;                                color = Color(0xFF4A90E2),&#10;                                fontWeight = FontWeight.Medium&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Column(horizontalAlignment = Alignment.End) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        // Category badge&#10;                        Surface(&#10;                            color = Color(0xFF4A90E2).copy(alpha = 0.1f),&#10;                            shape = RoundedCornerShape(12.dp),&#10;                            modifier = Modifier.padding(end = 4.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = todo.category,&#10;                                fontSize = 12.sp,&#10;                                color = Color(0xFF4A90E2),&#10;                                fontWeight = FontWeight.Medium,&#10;                                modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;                            )&#10;                        }&#10;&#10;                        // Priority indicator&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(8.dp)&#10;                                .background(&#10;                                    color = when (todo.priority) {&#10;                                        &quot;High&quot; -&gt; Color.Red&#10;                                        &quot;Medium&quot; -&gt; Color(0xFFFFA500)&#10;                                        else -&gt; Color(0xFF4CAF50)&#10;                                    },&#10;                                    shape = CircleShape&#10;                                )&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                        IconButton(onClick = onEdit) {&#10;                            Icon(&#10;                                Icons.Filled.MoreVert,&#10;                                contentDescription = &quot;More options&quot;,&#10;                                tint = Color(0xFFBDBDBD)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    if (todo.dueDate.isNotBlank()) {&#10;                        Text(&#10;                            text = &quot;Due: ${todo.dueDate}&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF757575),&#10;                            modifier = Modifier.padding(top = 4.dp, end = 12.dp)&#10;                        )&#10;                    }&#10;&#10;                    if (todo.streak &gt; 0) {&#10;                        Text(&#10;                            text = &quot; ${todo.streak} day streak&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFFFF5722),&#10;                            fontWeight = FontWeight.Medium,&#10;                            modifier = Modifier.padding(top = 4.dp, end = 12.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Calendar View component&#10;@Composable&#10;fun CalendarView(todos: List&lt;TodoItem&gt;) {&#10;    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    val calendar = Calendar.getInstance()&#10;    val currentMonth = calendar.get(Calendar.MONTH)&#10;    val currentYear = calendar.get(Calendar.YEAR)&#10;&#10;    // Group todos by date&#10;    val todosByDate = remember(todos) {&#10;        todos.filter { it.dueDate.isNotBlank() }&#10;             .groupBy { it.dueDate }&#10;    }&#10;&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        item {&#10;            Text(&#10;                text = &quot;Calendar View&quot;,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier.padding(bottom = 16.dp)&#10;            )&#10;        }&#10;&#10;        // Generate days for current month&#10;        val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;        calendar.set(Calendar.DAY_OF_MONTH, 1)&#10;        val firstDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1&#10;&#10;        // Days of week header&#10;        item {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                listOf(&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;).forEach { day -&gt;&#10;                    Text(&#10;                        text = day,&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        modifier = Modifier.weight(1f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;&#10;        // Calendar grid&#10;        val totalCells = ((daysInMonth + firstDayOfWeek + 6) / 7) * 7&#10;        items(totalCells / 7) { week -&gt;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                repeat(7) { dayOfWeek -&gt;&#10;                    val cellIndex = week * 7 + dayOfWeek&#10;                    val dayOfMonth = cellIndex - firstDayOfWeek + 1&#10;&#10;                    if (dayOfMonth in 1..daysInMonth) {&#10;                        val dateString = String.format(Locale.getDefault(), &quot;%04d-%02d-%02d&quot;, currentYear, currentMonth + 1, dayOfMonth)&#10;                        val todosForDay = todosByDate[dateString] ?: emptyList()&#10;&#10;                        CalendarDayCell(&#10;                            dayOfMonth = dayOfMonth,&#10;                            todos = todosForDay,&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    } else {&#10;                        Spacer(modifier = Modifier.weight(1f))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Today's tasks section&#10;        item {&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;            Text(&#10;                text = &quot;Today's Tasks&quot;,&#10;                fontSize = 18.sp,&#10;                fontWeight = FontWeight.SemiBold,&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;        }&#10;&#10;        val today = dateFormat.format(Date())&#10;        val todayTasks = todosByDate[today] ?: emptyList()&#10;&#10;        if (todayTasks.isEmpty()) {&#10;            item {&#10;                Text(&#10;                    text = &quot;No tasks for today&quot;,&#10;                    color = Color(0xFF757575),&#10;                    modifier = Modifier.padding(vertical = 8.dp)&#10;                )&#10;            }&#10;        } else {&#10;            items(todayTasks) { todo -&gt;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 4.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = if (todo.isDone) Color(0xFFF5F5F5) else Color.White&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(12.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = if (todo.isDone) &quot;&quot; else &quot;&quot;,&#10;                            fontSize = 16.sp,&#10;                            color = if (todo.isDone) Color(0xFF4CAF50) else Color(0xFF757575)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(12.dp))&#10;                        Text(&#10;                            text = todo.title,&#10;                            fontSize = 16.sp,&#10;                            color = if (todo.isDone) Color(0xFF757575) else Color(0xFF222222)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CalendarDayCell(&#10;    dayOfMonth: Int,&#10;    todos: List&lt;TodoItem&gt;,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .padding(2.dp)&#10;            .background(&#10;                color = if (todos.isNotEmpty()) Color(0xFF4A90E2).copy(alpha = 0.1f) else Color.Transparent,&#10;                shape = RoundedCornerShape(4.dp)&#10;            ),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = dayOfMonth.toString(),&#10;                fontSize = 14.sp,&#10;                color = Color(0xFF222222)&#10;            )&#10;            if (todos.isNotEmpty()) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(6.dp)&#10;                        .background(Color(0xFF4A90E2), CircleShape)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Activity Log Dialog component&#10;@Composable&#10;fun ActivityLogDialog(&#10;    activityLog: List&lt;ActivityLogEntry&gt;,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Icon(Icons.Filled.History, contentDescription = &quot;Activity Log&quot;)&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&quot;Activity Log&quot;)&#10;            }&#10;        },&#10;        text = {&#10;            if (activityLog.isEmpty()) {&#10;                Text(&quot;No activity yet. Start creating and managing tasks to see your activity here!&quot;)&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(400.dp)&#10;                ) {&#10;                    items(activityLog.sortedByDescending { it.timestamp }) { entry -&gt;&#10;                        ActivityLogItem(entry)&#10;                        if (entry != activityLog.last()) {&#10;                            HorizontalDivider(modifier = Modifier.padding(vertical = 4.dp))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Close&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun ActivityLogItem(entry: ActivityLogEntry) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = entry.taskTitle,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    val actionIcon = when (entry.action) {&#10;                        &quot;created&quot; -&gt; &quot;&quot;&#10;                        &quot;completed&quot; -&gt; &quot;&quot;&#10;                        &quot;uncompleted&quot; -&gt; &quot;&quot;&#10;                        &quot;updated&quot; -&gt; &quot;&quot;&#10;                        &quot;deleted&quot; -&gt; &quot;&quot;&#10;                        &quot;comment_added&quot; -&gt; &quot;&quot;&#10;                        &quot;progress_updated&quot; -&gt; &quot;&quot;&#10;                        else -&gt; &quot;&quot;&#10;                    }&#10;                    Text(&#10;                        text = actionIcon,&#10;                        fontSize = 14.sp,&#10;                        modifier = Modifier.padding(end = 4.dp)&#10;                    )&#10;                    Text(&#10;                        text = entry.action.replace(&quot;_&quot;, &quot; &quot;).replaceFirstChar {&#10;                            if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString()&#10;                        },&#10;                        fontSize = 14.sp,&#10;                        color = Color(0xFF4A90E2),&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                }&#10;                if (entry.details.isNotBlank()) {&#10;                    Text(&#10;                        text = entry.details,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF757575),&#10;                        modifier = Modifier.padding(top = 2.dp)&#10;                    )&#10;                }&#10;            }&#10;            Text(&#10;                text = formatTimestamp(entry.timestamp),&#10;                fontSize = 12.sp,&#10;                color = Color(0xFF757575)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// Task Details Dialog component&#10;@Composable&#10;fun TaskDetailsDialog(&#10;    todo: TodoItem,&#10;    onDismiss: () -&gt; Unit,&#10;    onAddComment: (String) -&gt; Unit,&#10;    onUpdateProgress: (Int) -&gt; Unit&#10;) {&#10;    var newComment by remember { mutableStateOf(&quot;&quot;) }&#10;    var progressValue by remember { mutableIntStateOf(todo.completionPercentage) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Icon(Icons.Filled.Timeline, contentDescription = &quot;Task Details&quot;)&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&quot;Task Details&quot;)&#10;            }&#10;        },&#10;        text = {&#10;            LazyColumn(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(500.dp)&#10;            ) {&#10;                // Task Info&#10;                item {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = CardDefaults.cardColors(containerColor = Color(0xFFF5F5F5))&#10;                    ) {&#10;                        Column(modifier = Modifier.padding(16.dp)) {&#10;                            Text(&#10;                                text = todo.title,&#10;                                fontSize = 18.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;                            if (todo.notes.isNotBlank()) {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Text(&#10;                                    text = todo.notes,&#10;                                    fontSize = 14.sp,&#10;                                    color = Color(0xFF757575)&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                            // Progress Section&#10;                            Text(&#10;                                text = &quot;Progress&quot;,&#10;                                fontSize = 16.sp,&#10;                                fontWeight = FontWeight.SemiBold&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                            Slider(&#10;                                value = progressValue.toFloat(),&#10;                                onValueChange = { progressValue = it.toInt() },&#10;                                valueRange = 0f..100f,&#10;                                steps = 19, // 5% increments&#10;                                modifier = Modifier.fillMaxWidth()&#10;                            )&#10;                            Text(&#10;                                text = &quot;$progressValue% Complete&quot;,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFF4A90E2),&#10;                                textAlign = TextAlign.Center,&#10;                                modifier = Modifier.fillMaxWidth()&#10;                            )&#10;&#10;                            if (progressValue != todo.completionPercentage) {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Button(&#10;                                    onClick = {&#10;                                        onUpdateProgress(progressValue)&#10;                                    },&#10;                                    modifier = Modifier.fillMaxWidth()&#10;                                ) {&#10;                                    Text(&quot;Update Progress&quot;)&#10;                                }&#10;                            }&#10;&#10;                            // Task Stats&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            HorizontalDivider()&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween&#10;                            ) {&#10;                                Column {&#10;                                    Text(&quot;Category&quot;, fontSize = 12.sp, color = Color(0xFF757575))&#10;                                    Text(todo.category, fontSize = 14.sp, fontWeight = FontWeight.Medium)&#10;                                }&#10;                                Column {&#10;                                    Text(&quot;Priority&quot;, fontSize = 12.sp, color = Color(0xFF757575))&#10;                                    Text(&#10;                                        text = todo.priority,&#10;                                        fontSize = 14.sp,&#10;                                        fontWeight = FontWeight.Medium,&#10;                                        color = when (todo.priority) {&#10;                                            &quot;High&quot; -&gt; Color.Red&#10;                                            &quot;Medium&quot; -&gt; Color(0xFFFFA500)&#10;                                            else -&gt; Color(0xFF4CAF50)&#10;                                        }&#10;                                    )&#10;                                }&#10;                                if (todo.streak &gt; 0) {&#10;                                    Column {&#10;                                        Text(&quot;Streak&quot;, fontSize = 12.sp, color = Color(0xFF757575))&#10;                                        Text(&quot; ${todo.streak}&quot;, fontSize = 14.sp, fontWeight = FontWeight.Medium)&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            if (todo.dueDate.isNotBlank()) {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Text(&quot;Due Date&quot;, fontSize = 12.sp, color = Color(0xFF757575))&#10;                                Text(todo.dueDate, fontSize = 14.sp, fontWeight = FontWeight.Medium)&#10;                            }&#10;                        }&#10;                    }&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;&#10;                // Comments Section&#10;                item {&#10;                    Text(&#10;                        text = &quot;Comments (${todo.comments.size})&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    // Add comment&#10;                    OutlinedTextField(&#10;                        value = newComment,&#10;                        onValueChange = { newComment = it },&#10;                        placeholder = { Text(&quot;Add a comment...&quot;) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        trailingIcon = {&#10;                            IconButton(&#10;                                onClick = {&#10;                                    if (newComment.isNotBlank()) {&#10;                                        onAddComment(newComment)&#10;                                        newComment = &quot;&quot;&#10;                                    }&#10;                                }&#10;                            ) {&#10;                                Icon(Icons.AutoMirrored.Filled.Comment, contentDescription = &quot;Add comment&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                }&#10;&#10;                // Comments list&#10;                if (todo.comments.isEmpty()) {&#10;                    item {&#10;                        Text(&#10;                            text = &quot;No comments yet. Add one above!&quot;,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF757575),&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    }&#10;                } else {&#10;                    items(todo.comments.sortedByDescending { it.timestamp }) { comment -&gt;&#10;                        CommentItem(comment)&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                    }&#10;                }&#10;&#10;                // Attachments Section (placeholder for future implementation)&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Attachments (${todo.attachments.size})&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    if (todo.attachments.isEmpty()) {&#10;                        Text(&#10;                            text = &quot;No attachments&quot;,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF757575)&#10;                        )&#10;                    } else {&#10;                        // Placeholder for attachments display&#10;                        todo.attachments.forEach { attachment -&gt;&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFFF8F8F8))&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier.padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        Icons.Filled.Attachment,&#10;                                        contentDescription = &quot;Attachment&quot;,&#10;                                        tint = Color(0xFF4A90E2)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Column {&#10;                                        Text(attachment.name, fontWeight = FontWeight.Medium)&#10;                                        Text(&#10;                                            attachment.type,&#10;                                            fontSize = 12.sp,&#10;                                            color = Color(0xFF757575)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Close&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun CommentItem(comment: TaskComment) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFFF8F8F8))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;&quot;,&#10;                    fontSize = 16.sp&#10;                )&#10;                Text(&#10;                    text = formatTimestamp(comment.timestamp),&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF757575)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = comment.text,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// Utility function to format timestamps&#10;fun formatTimestamp(timestamp: String): String {&#10;    return try {&#10;        val sdf = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;        val date = sdf.parse(timestamp)&#10;        val now = Date()&#10;        val diffInMs = now.time - (date?.time ?: 0)&#10;        val diffInMinutes = diffInMs / (1000 * 60)&#10;        val diffInHours = diffInMs / (1000 * 60 * 60)&#10;        val diffInDays = diffInMs / (1000 * 60 * 60 * 24)&#10;&#10;        when {&#10;            diffInMinutes &lt; 1 -&gt; &quot;Just now&quot;&#10;            diffInMinutes &lt; 60 -&gt; &quot;${diffInMinutes}m ago&quot;&#10;            diffInHours &lt; 24 -&gt; &quot;${diffInHours}h ago&quot;&#10;            diffInDays &lt; 7 -&gt; &quot;${diffInDays}d ago&quot;&#10;            else -&gt; {&#10;                val displaySdf = SimpleDateFormat(&quot;MMM dd&quot;, Locale.getDefault())&#10;                displaySdf.format(date ?: Date())&#10;            }&#10;        }&#10;    } catch (_: Exception) {&#10;        &quot;Unknown&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>